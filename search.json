[{"title":"字典树","url":"/2022/07/27/905bc6844e49/","content":"\n# 字典树\n\n什么是字典树？\n\n字典树，是关于“字典”的一棵树，是一串针对字符串进行维护的数据结构。它是对于字典的一种存储方式，对于每个单词，从根节点出发到某一目标节点，路径书上所有节点连起来就是一个单词。\n\n如图，我们目前有6个字符串：animal anxiety apple cross cxy qzh\n构成了一棵树，其中具有相同前缀的字符串在树上具有部分相同的结构。可以看出字典树的本质是把很多字符串拆成单个字符的形式存储起来，所以说其维护的是“字典”。\n\n\n![Trie树图解](https://raw.githubusercontent.com/KillingCommendatore/KillingCommendatore.github.io/main/images/72M9%245W%7DXUY%60FK62LB83R5S.jpg)\n\n## 字典树的应用：\n\n1.维护字符串集合（字典）\n\n2.向字典中插入字符串（建树）\n\n3.查询字典中是否含有某个字符串（查询）\n\n4.统计字符串在集合中出现的个数（统计）\n\n5.将字符串集合按字典序排序（排序）\n\n6.求两个字符串的最长公共前缀\n\n## 字典树的实现\n\n字典树的两种基本操作是建树和查询。\n\n### 建树基本思路：\n\n开一个数组 $tree[100010][65]$（不严格），对于字符串的每一个字符查询该字符对应数字（如'a'对应0）是否建立节点，如果建立节点那么跳到下一个字符并且向深处插入，如果没有建立节点就在该处建立节点。\n\n举例：目前有两个单词 $anxiety$ 和 $animal$ \n\n先对 $anxiety$ 进行建树，可以发现此前并无任何节点，那么过程有：\n\n$tree[0][a]=1$\n\n$tree[a][n]=2$\n\n$tree[n][x]=3$\n\n$tree[x][i]=4$\n\n$...$\n\n建完以后，再对 $animal$ 进行建树：\n\n发现：\n\n$tree[0][a]$ 是已经建立好的节点，那么不用新建立了，直接看下一个节点\n\n发现： $tree[a][n]$ 也建立好了，继续看下一个节点\n\n$tree[n][i]$ 未被建立，那么建立该节点，$tree[n][i]=8$\n\n如何判断一个节点是否被建立？即从该字符到下一个字符是否有编号：\n\n```cpp\nif (tree[root][ch] == 0)//对应的数字没有建立节点\n\ttree[root][ch] = ++cnt;//新节点的编号\n```\n对于查询操作而言，基本思路与插入操作相同。\n\n如果没找到节点返回0，所有节点都找到退出循环后返回1。\n\n\n### 初始化\n\n把字符转化成数字存储在字典种\n```cpp\nint getnum(char x)//将字符转化成0-62之间的数字\n{\n\tif (x >= 'A' && x <= 'Z')\n\t\treturn x - 'A';\n\telse if (x >= 'a' && x <= 'z')\n\t\treturn x - 'a' + 26;\n\telse\n\t\treturn x - '0' + 52;\n}\n```\n### 插入操作\n\n```cpp\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t}\n}\n```\n\n### 查询操作\n\n```cpp\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn 1;\n}\n```\n\n# 洛谷题面\n\n## 【模板】字典树\n\n## 题目描述\n\n给定 $n$ 个模式串 $s_1, s_2, \\dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \\sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。\n\n一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。\n\n输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。\n\n## 输入格式\n\n**本题单测试点内有多组测试数据**。  \n\n输入的第一行是一个整数，表示数据组数 $T$。\n\n对于每组数据，格式如下：  \n第一行是两个整数，分别表示模式串的个数 $n$ 和询问的个数 $q$。  \n接下来 $n$ 行，每行一个字符串，表示一个模式串。  \n接下来 $q$ 行，每行一个字符串，表示一次询问。\n\n## 输出格式\n\n按照输入的顺序依次输出各测试数据的答案。  \n对于每次询问，输出一行一个整数表示答案。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n3 3\nfusufusu\nfusu\nanguei\nfusu\nanguei\nkkksc\n5 2\nfusu\nFusu\nAFakeFusu\nafakefusu\nfusuisnotfake\nFusu\nfusu\n1 1\n998244353\n9\n```\n\n### 样例输出 #1\n\n```\n2\n1\n0\n1\n2\n1\n```\n\n## 提示\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T, n, q\\leq 10^5$，且输入字符串的总长度不超过 $3 \\times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。\n\n### 说明\nstd 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。\n\n## 思路\n\n为每个节点建立数量数组 $sum[]$ ，对于每个节点（节点代表了从根节点到目前节点的这串单词），在插入操作时在每个节点+1，即：\n\n```cpp\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t\tsum[root]++;//从0节点到该节点（即一个前缀）的数量+1\n\t}\n}\n```\n\n在查询操作时，如果查询到该字符串，直接返回最后一个节点（字符串的最后一个字符）的sum值即可\n\n```cpp\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn sum[root];//返回插入操作中弄好的数量\n}\n```\n\n所有代码：\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int mxn = 3e6 + 10;\nint tree[mxn][65], cnt = 0, sum[mxn];\nchar s[mxn];\nint n, m;\nint getnum(char x)//将字符转化成0-62之间的数字\n{\n\tif (x >= 'A' && x <= 'Z')\n\t\treturn x - 'A';\n\telse if (x >= 'a' && x <= 'z')\n\t\treturn x - 'a' + 26;\n\telse\n\t\treturn x - '0' + 52;\n}\nvoid Insert(char str[])//插入操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//对应的数字没有建立节点\n\t\t\ttree[root][ch] = ++cnt;//新节点的编号\n\t\troot = tree[root][ch];//向深处插入\n\t\tsum[root]++;//从0节点到该节点（即一个前缀）的数量+1\n\t}\n}\nint Search(char str[])//查询操作\n{\n\tint root = 0;\n\tfor (int i = 0; i < strlen(str); i++)\n\t{\n\t\tint ch = getnum(str[i]);\n\t\tif (tree[root][ch] == 0)//没有查询到这个节点，退出\n\t\t\treturn 0;\n\t\troot = tree[root][ch];//查询到了，继续向深处查询\n\t}\n\treturn sum[root];//返回插入操作中弄好的数量\n}\nint main()\n{\n\tint T = 0;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tfor (int i = 0; i <= cnt; i++)//从0开始，因为字符转换成数字也是从0开始\n\t\t\tfor (int j = 0; j <= 64; j++)\n\t\t\t\ttree[i][j] = 0;\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\tsum[i] = 0;\n\t\tcnt = 0;\n\t\tcin >> n >> m;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\tInsert(s);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\tcout << Search(s) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```","tags":["字符串","字典树"],"categories":["笔记"]},{"title":"字符串hash","url":"/2022/07/26/7c7df27e203e/","content":"\n# 字符串哈希\n\n### 为什么要学习字符串哈希\n\nC++在比较两个字符串的时候效率不高，需要设计一种更高效的算法来匹配字符串。\n\n用途：\n\n1.判断两个字符串是否相等\n\n2.判断一个字符串是否出现过\n\n### 什么是哈希\n\nHash，一般称为散列，音译为哈希，是将任意长度的输入通过散列算法变换成固定的输出，该输出就是散列值\n\n即：把字符串赋予进制和模数，把每一个字符映射成一个小于等于模数的数字。\n\n例如：取进制为32进制，模数为1145141919810，字符串 'qzh' 的哈希值为：\n\n$ASCII[q]*32^2+ASCII[z]*32^1+ASCII[h]*32^0$  $mod$  $114514$\n\n可以算出该字符串的hash值为$113*32*32 + 122*32 + 104=119720$ \n\n但是，Hash并非完美无缺：当另外一个字符串的Hash值等与119720时，便会出现两个字符串共用hash值，但是两个字符串并不相同，即Hash冲突。\n\n如何解决Hash冲突问题？\n\n1.模数选择大质数\n\n选择小质数会导致有剩余系过小，hash冲突概率增大，选合数会导致剩余系的浪费。\n\n2.双模数Hash\n\n用两种不同方法hash，然后比对每一种hash值是否相同，增加了空间和时间，但是也增加了正确性。\n\n洛谷字符串Hash题面：\n\n## 【模板】字符串哈希\n\n## 题目描述\n\n如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。\n\n\n友情提醒：如果真的想好好练习哈希的话，请自觉，否则请右转PJ试炼场:)\n\n## 输入格式\n\n第一行包含一个整数 $N$，为字符串的个数。\n\n接下来 $N$ 行每行包含一个字符串，为所提供的字符串。\n\n## 输出格式\n\n输出包含一行，包含一个整数，为不同的字符串个数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\nabc\naaaa\nabc\nabcc\n12345\n```\n\n### 样例输出 #1\n\n```\n4\n```\n\n## 提示\n\n对于 $30\\%$ 的数据：$N\\leq 10$，$M_i≈6$，$Mmax\\leq 15$。\n\n对于 $70\\%$ 的数据：$N\\leq 1000$，$M_i≈100$，$Mmax\\leq 150$。\n\n对于 $100\\%$ 的数据：$N\\leq 10000$，$M_i≈1000$，$Mmax\\leq 1500$。\n\n\n样例说明：\n\n样例中第一个字符串(abc)和第三个字符串(abc)是一样的，所以所提供字符串的集合为{aaaa,abc,abcc,12345}，故共计4个不同的字符串。\n\n\nTip：\n感兴趣的话，你们可以先看一看以下三题：\n\nBZOJ3097：http://www.lydsy.com/JudgeOnline/problem.php?id=3097\n\nBZOJ3098：http://www.lydsy.com/JudgeOnline/problem.php?id=3098\n\nBZOJ3099：http://www.lydsy.com/JudgeOnline/problem.php?id=3099\n\n如果你仔细研究过了（或者至少仔细看过AC人数的话），我想你一定会明白字符串哈希的正确姿势的^\\_^\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst unsigned long long mod=212370440130137957ll;//搞个大模数\nconst unsigned int basee=32;//32进制\nconst int prime=19260817;//搞个大质(xin)数(wen)\nint cnt=0;\nunsigned long long N,a[10010];\nunsigned long long hsh(char n[])\n{\n\tunsigned long long ans=0;\n\tint length=strlen(n);\n\tfor(int i=0;i<length;i++)//每个字符都hash一下\n\t{\n\t\tans=(ans*basee+n[i])%mod+prime;//每次都取模并加上大质数\n\t}\n\treturn ans;//返回该字符串的哈希值\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tchar s[1510]={0};\n\t\tcin>>s;\n\t\ta[i]=hsh(s);\n\t}\n\tsort(a+1,a+N+1);\n\tfor(int i=1;i<=N;i++)\n\t\tif(a[i]!=a[i+1])cnt++;\n\tcout<<cnt;\n\treturn 0;\n}\n```","tags":["字符串","哈希"],"categories":["笔记"]},{"title":"暑期中段反思","url":"/2022/07/10/a97c74d48428/","content":"\n## 汇编语言没好好学\n\n教汇编语言的朱教授相当好，但是课没好好听，作业也没有好好做，感觉很愧疚。今天（7/10）要把第二次上机和之前的作业都补完，早点睡觉，明天好好听课。\n\n## ACM也荒废了\n\n自从上汇编以后就再也没写过题\n\n## 浪费大量时间在懂球帝上\n\n切尔西恼人的夏季转会窗，花了很多时间看新闻，甚至和巴萨球迷对喷，这些都是没有意义的。说实话，我在考虑写个自动搬运新闻的bot去推特上爬取新闻，这样就不用看评论区而可以享受到纯净新闻了。\n\n目前卸载了懂球帝，之后用电脑端看看新闻吧，再也不要陷入骂战了。\n\n好好学汇编和acm，再学一门新语言。","tags":["碎碎念"],"categories":["随笔"]},{"title":"线段树代码注释","url":"/2022/07/04/f1225d3398cc/","content":"线段树笔记见：https://zhuanlan.zhihu.com/p/106118909 \n\n非常优秀的一篇笔记，个人感觉看完以后完全弄懂了，认为我没必要再花精力写一篇不如它且不能太增长个人理解的笔记。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=100010;\nint n,m,A[maxn*4],mark[maxn*4],tree[maxn*4];\nvoid buildtree(int l=1,int r=n,int p=1)\n{\n\tif(l==r)//到了叶子节点，l=r\n\t\ttree[p]=A[l];//注意这里是树的编号\n\telse\n\t{\n\t\tint mid=(l+r)/2;\n\t\tbuildtree(l,mid,2*p);//左右递归建立线段树\n\t\tbuildtree(mid+1,r,2*p+1);\n\t\ttree[p]=tree[2*p]+tree[2*p+1];//等与左右区间之和\n\t}\n}\nvoid push_down(int p,int len)//传递懒惰标记函数，p是节点编号，len是区间长度\n{\n\tmark[p*2]+=mark[p];//传递给左右区间，原先可能已经有懒惰标记因此是+=\n\tmark[p*2+1]+=mark[p];\n\ttree[p*2]+=mark[p]*(len-len/2);//左右区间权值加上懒惰标记（加了多少）乘区间长度\n\ttree[p*2+1]+=mark[p]*(len/2);//右区间短一点\n\tmark[p]=0; \n}\nvoid upd(int l,int r,int d,int p=1,int cl=1,int cr=n)\n//cl与cr是当前区间，l和r是要求的区间，d是加了多少\n{\n\tif(cl>r || cr<l)return;\n\telse if(cl>=l && cr<=r)\n\t{\n\t\ttree[p]+=d*(cr-cl+1);//区间加上权值乘区间长度\n\t\tif(cr>cl)\n\t\t\tmark[p]+=d;//不是叶子节点，打上懒惰标记\n\t}\n\telse\n\t{\n\t\tint mid=(cl+cr)/2;\n\t\tpush_down(p,cr-cl+1);//左右区间打上懒惰标记\n\t\tupd(l,r,d,p*2,cl,mid);//继续往下更新左右区间\n\t\tupd(l,r,d,p*2+1,mid+1,cr);\n\t\ttree[p]=tree[2*p]+tree[2*p+1];//加一加\n\t}\n}\nint qry(int l,int r,int p=1,int cl=1,int cr=n)\n{\n\tif(cl>r || cr<l)\n\t\treturn 0;\n\telse if(cl>=l && cr<=r)\n\t\treturn tree[p];\n\telse\n\t{\n\t\tint mid=(cl+cr)/2;\n\t\tpush_down(p,cr-cl+1);\n        //之前更新的时候有不少没有清除的懒惰标记，在询问中把懒惰标记加到区间上\n\t\treturn qry(l,r,p*2,cl,mid)+qry(l,r,p*2+1,mid+1,cr);//左右区间相加\n\t}\n}\nsigned main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>A[i];\n\tbuildtree();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint opt;\n\t\tcin>>opt;\n\t\tif(opt==1)\n\t\t{\n\t\t\tint x,y,k;\n\t\t\tcin>>x>>y>>k;\n\t\t\tupd(x,y,k);\n\t\t}\n\t\telse if(opt==2)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcout<<qry(x,y)<<endl; \n\t\t}\n\t}\n\treturn 0;\n}\n```","tags":["线段树"],"categories":["笔记"]},{"title":"算法学习笔记（2）-st表","url":"/2022/07/02/d8b19258ae62/","content":"\n# 【模板】ST 表\n\n## 题目背景\n\n这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n## 题目描述\n\n给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n\n## 输入格式\n\n第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。\n\n## 输出格式\n\n输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n8 8\n9 3 1 7 5 6 0 8\n1 6\n1 5\n2 7\n2 6\n1 8\n4 8\n3 7\n1 8\n```\n\n### 样例输出 #1\n\n```\n9\n9\n7\n7\n9\n8\n7\n9\n```\n\n## 提示\n\n对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。\n\n## 什么是st表\n\nST 表是用于解决 **可重复贡献问题** 的数据结构。主要用于解决 **RMQ** 问题，主要应用 **倍增** 的思想，可以实现区间最值的 $O(nlogn)$ 预处理， $O(1)$ 查询。\n\n### 可重复贡献问题\n\n举例来说：要你求10个数中的最大数，你完全可以先求前6个数的 $max$ ，再求后7个数的 $max$ ，然后再对所求的两个最大数求 $max$ 。虽然中间有四个数被重复计算了，但并不影响最后的答案。\n\n**常见的可重复贡献问题有：** 区间最值、区间按位和、区间按位或、区间GCD等。二而像区间和这样的问题就不是可重复贡献问题。\n\n**RMQ问题** RMQ问题即区间最大最小值问题，是英文 Range Maximum/Minimum Query 的缩写。\n\n### st表的构建\n\nst表基于倍增算法，用一个二维数组 $f[i][j]$ 表示区间 $[i,i+2^j-1]$ 内的最值，显然 $f[i][0]=max(i,i)=num_i$\n\n由倍增思想可知：跳 $2^i$ 步等与先跳 $2^{i-1}$ 步再跳 $2^{i-1}$ 步，因此，区间 $[i,i+2^j-1]$ 的最值可以看作区间 $[i,i+2^{j-1}-1]$ 的最值和区间 $[i+2^{j-1},i+2^j-1]$ 的最值。\n\n可以得到dp公式： $f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])$ \n\n$f[i][j-1]$ ：$i$ 向右跳 $2^{j-1}$ 步\n\n$f[i+2^{j-1}][j-1]$ ： $i+2^{j-1}$ 向右跳 $2^{j-1}$ 步，其中 $i+2^{j-1}$ = $f[i][j-1] + 1$\n\n接下来通过枚举区间长度 $j$ 和起点 $i$ 可构建出st表。 \n\n原理如图所示\n![](https://pic4.zhimg.com/80/v2-22d8a24faea894fb8ddceae627093bbf_1440w.jpg)\n\n```cpp\nfor(int j=1;j<=lg;j++)\n\tfor(int i=1;i+(1<<j)-1<=n;i++)//跳跃的范围要小于n（边界）\n\t\tf[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n```\n\n### 处理询问\n\n当处理区间 $[l,r]$ 内的最值时，我们需要找到两个 $[l,r]$ 的子区间，使得其并集正好是 $[l,r]$ （不必不相交）。具体地，我们要找一个整数 $s$ ，使得两个子区间分别为 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 。\n![](https://pic4.zhimg.com/80/v2-9d09b3492f0c0cbaa7555a56b22c1693_1440w.jpg) \n我们希望前一个子区间的右端点尽可能接近 $r$ （我们倾向于直接输出 $f[l][r]$）。因此，当 $l+2^s-1=r$ 时，有 $s=log_2(r-l+1)$ （这时 $r-2^s+1=l$ 也成立）。由于 $s$ 是整数，我们向下取整。\n\n同时，每次计算log过于耗费时间，我们在最开始对log进行预处理：\n```cpp\nvoid pre()\n{\n\tlogn[1]=0,logn[2]=1;\n\tfor(int i=3;i<maxn;i++){\n\t\tlogn[i]=logn[i/2]+1;//向下取整\n\t}\n}\n```\n\n在线查询：\n```cpp\nfor(int i=1;i<=m;i++)\n{\n\tint l,r;\n\tscanf(\"%d%d\",&l,&r);\n\tint lg=logn[r-l+1];\n\tint ans=max(f[l][lg],f[r-(1<<lg)+1][lg]);\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n### 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100010;\nconst int logN=22;\nint f[maxn][25],n,m,logn[maxn+1];\nvoid pre()//预处理log值\n{\n\tlogn[1]=0,logn[2]=1;\n\tfor(int i=3;i<maxn;i++){\n\t\tlogn[i]=logn[i/2]+1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&f[i][0]);\n\tpre();\n\tfor(int i=1;i<=logN;i++)\n\t\tfor(int j=1;j+(1<<i)-1<=n;j++)\n\t\t\tf[j][i]=max(f[j][i-1],f[j+(1<<(i-1))][i-1]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tint lg=logn[r-l+1];\n\t\tint ans=max(f[l][lg],f[r-(1<<lg)+1][lg]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```","tags":["st表"],"categories":["笔记"]},{"title":"P2015 二叉苹果树","url":"/2022/07/01/72b062651e38/","content":"# 二叉苹果树\n\n## 题目描述\n\n有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）\n\n这棵树共有 $N$ 个结点（叶子点或者树枝分叉点），编号为 $1 \\sim N$，树根编号一定是 $1$。\n\n我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 $4$ 个树枝的树：\n\n```\n2   5\n \\ / \n  3   4\n   \\ /\n    1\n```\n\n现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。\n\n给定需要保留的树枝数量，求出最多能留住多少苹果。\n\n## 输入格式\n\n第一行 $2$ 个整数 $N$ 和 $Q$，分别表示表示树的结点数，和要保留的树枝数量。\n\n接下来 $N-1$ 行，每行 $3$ 个整数，描述一根树枝的信息：前 $2$ 个数是它连接的结点的编号，第 $3$ 个数是这根树枝上苹果的数量。\n\n## 输出格式\n\n一个数，最多能留住的苹果的数量。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 2\n1 3 1\n1 4 10\n2 3 20\n3 5 20\n```\n\n### 样例输出 #1\n\n```\n21\n```\n\n## 提示\n\n$1 \\leqslant Q < N \\leqslant 100$，每根树枝上的苹果 $\\leqslant 3 \\times 10^4$。\n\n## 思路\n\n和选课一样同为树形背包，对于每一个节点有：\n\n$f[x][i]=max(f[x][i],f[x][i-j-1]+f[son][j]+e[i].cost)$\n\n其中 $f[x][i]$ 代表以 $x$ 为节点，保留 $i$ 根树枝能获得的最多苹果树。观察右边式子 $f[x][i-j-1]+f[son][j]+e[i].cost$ 可以发现，另一个选择是在子树上选择 $j$ 根树枝，那为什么根上的树枝要减去 $j+1$ 根呢？因为根和子树也要连起来，他们中间也需要一根树枝进行连接，它的苹果数量即 $e[i].cost$ 。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nint cnt,n,q,head[N*2],f[N][N];\nstruct edge{\n\tint to,nxt,cost;\n}e[N*2];\nvoid add(int u,int v,int w)\n{\n\te[++cnt].to=v;\n\te[cnt].cost=w;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tdp(e[i].to);//从子结构开始进行dp\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tfor(int j=q;j>=1;j--)//q是最多保留树枝，即从容量开始倒序查找，与一维01背包同理\n\t\t{\n\t\t\tfor(int k=j-1;k>=0;k--)//子树上的树枝要少于根上的树枝\n\t\t\t{\n\t\t\t\tf[x][j]=max(f[x][j],f[x][j-k-1]+f[v][k]+e[i].cost);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\tadd(u,v,w);\n\t}\n\tdp(1);\n\tcout<<f[1][q];\n\treturn 0;\n}\n```","tags":["树形结构","树形dp","树形背包"],"categories":["题解"]},{"title":"综合训练洛谷题单","url":"/2022/07/01/4f0e948c3e36/","content":"洛谷试炼场的题目确实很具有代表性，但是近几年以来，又有许多经典题目出现在 OI 界中，这个大题单就是作为洛谷试炼场的扩展和补充。\n\n## Copyleft\n\n[![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.zh)\n\n本项目采用 [知识共享署名-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-sa/4.0/deed.zh) 以及附加的 [The Star And Thank Author License](https://github.com/zTrix/sata-license) 进行许可。\n\n换言之，您可以自由的共享并演绎该项目，但是必须给出必要的署名，并以相同方式共享本项目，并为本项目的 [Github 仓库](https://github.com/SFOI-Team/luogu-problem-list) 点赞（Star）。\n\n## 新版本食用指南\n\n**本次版本更新变更较大，建议您仔细阅读下面的内容！**\n\n在刚刚更新的 2.0 版本中，我们改变了原来按知识难度排列知识点的目录结构，改为按照专题大类组织目录结构。\n\n为了方便按知识难度刷题的用户，这里给出一些建议：\n\n- 对于初学者，建议先完成 Part 1,2 两部分内容，为接下来的学习打好基础。\n- 对于要参加 CSP-S 的选手，建议在前面的基础上优先完成 Part 3.1-3.4, 4.1-4.4, 6.1-6.5, 7.1-7.8, 8.1-8.7 的内容（具体内容见下），在此基础上继续完成其他内容。\n- 每个专题下的题目先给出模板，剩下的题目均按照难度递增顺序排序，部分难度较高的综合性题目建议达到一定能力后再尝试解决。\n\n## 更新日志\n\n3.0.2 2020/2/28：\n\n1. 添加了少量比赛题目；\n2. 移除了一些做法重复的题目。\n\n3.0.1 2019/12/8：\n\n1. 添加了 CSP2019 和一些公开赛的题目；\n2. 跟进洛谷域名更换，将题目链接全部更新。\n\n3.0 2019/10/13：\n\n1. 新增专题：回文自动机，K-D Tree，自适应辛普森法，左偏树，置换群，离线算法，构造，DLX，三分法，珂朵莉树。\n2. 添加了一些最近的公开比赛题目，部分专题补充了一些优质题目。\n3. 移除了部分重复题目。\n4. 对之前没有介绍的专题补充了介绍。\n\n[更早版本的更新日志请点击这里查看](https://github.com/SFOI-Team/luogu-problem-list/blob/master/history.md)\n\n## Part 0 试机题\n\n> 三道试机题目。\n\n- [P1000 超级玛丽游戏](https://www.luogu.com.cn/problem/P1000)\n- [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)\n- [P1008 三连击](https://www.luogu.com.cn/problem/P1008)\n\n## Part 1 入门阶段\n\n> 本部分内容针对入门 OIer ，主要是语言基础内容。\n\n### Part 1.1 从零开始\n\n> 语言基础题。\n\n- [P1421 小玉买文具](https://www.luogu.com.cn/problem/P1421)\n- [P1909 买铅笔](https://www.luogu.com.cn/problem/P1909)\n- [P1089 津津的储蓄计划](https://www.luogu.com.cn/problem/P1089)\n- [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)\n- [P1035 级数求和](https://www.luogu.com.cn/problem/P1035)\n- [P1980 计数问题](https://www.luogu.com.cn/problem/P1980)\n- [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)\n- [P1307 数字反转](https://www.luogu.com.cn/problem/P1307)\n\n### Part 1.2 数组基础\n\n> 数组可以用于存储大量的信息。\n\n- [P1046 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046)\n- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)\n- [P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427)\n- [P2141 珠心算测验](https://www.luogu.com.cn/problem/P2141)\n- [P5594 【XR-4】模拟赛](https://www.luogu.com.cn/problem/P5594)\n\n### Part 1.3 字符串基础\n\n> 字符串是特殊的数组，但它也有很多自身的特点。\n\n- [P5015 标题统计](https://www.luogu.com.cn/problem/P5015)\n- [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)\n- [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)\n- [P2010 回文日期](https://www.luogu.com.cn/problem/P2010)\n- [P1012 拼数](https://www.luogu.com.cn/problem/P1012)\n- [P5587 打字练习](https://www.luogu.com.cn/problem/P5587)\n\n### Part 1.4 函数，递归及递推\n\n> 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。\n\n- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)\n- [P1036 选数](https://www.luogu.com.cn/problem/P1036)\n- [P1464 Function](https://www.luogu.com.cn/problem/P1464)\n- [P5534 【XR-3】等差数列](https://www.luogu.com.cn/problem/P5534)\n- [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)\n- [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)\n- [P4994 终于结束的起点](https://www.luogu.com.cn/problem/P4994)\n\n## Part 2 基础算法\n\n> 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。\n>\n> 当然，这里面也有一些难度比较高的题目。\n\n### Part 2.1 模拟\n\n> 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。\n>\n> 这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。\n\n- [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)\n- [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067)\n- [P1328 生活大爆炸版石头剪刀布](https://www.luogu.com.cn/problem/P1328)\n- [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563)\n- [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)\n- [P1179 数字统计](https://www.luogu.com.cn/problem/P1179)\n- [P2615 神奇的幻方](https://www.luogu.com.cn/problem/P2615)\n- [P3952 时间复杂度](https://www.luogu.com.cn/problem/P3952)\n- [P2482 [SDOI2010]猪国杀](https://www.luogu.com.cn/problem/P2482)\n- [P5380 [THUPC2019]鸭棋](https://www.luogu.com.cn/problem/P5380)\n\n### Part 2.2 排序算法\n\n> 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。\n\n- [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)\n- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)\n- [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)\n- [P1051 谁拿了最多奖学金](https://www.luogu.com.cn/problem/P1051)\n- [P1309 瑞士轮](https://www.luogu.com.cn/problem/P1309)\n- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)\n\n### Part 2.3 二分答案\n\n> 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。\n\n- [P1024 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)\n- [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)\n- [P1824 进击的奶牛](https://www.luogu.com.cn/problem/P1824)\n- [P1902 刺杀大使](https://www.luogu.com.cn/problem/P1902)\n- [P1314 聪明的质监员](https://www.luogu.com.cn/problem/P1314)\n- [P1083 借教室](https://www.luogu.com.cn/problem/P1083)\n- [P4343 [SHOI2015]自动刷题机](https://www.luogu.com.cn/problem/P4343)\n\n### Part 2.4 分治\n\n> 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。\n\n- [P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)\n- [P1010 幂次方](https://www.luogu.com.cn/problem/P1010)\n- [P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)\n- [P3612 [USACO17JAN]Secret Cow Code](https://www.luogu.com.cn/problem/P3612)\n\n### Part 2.5 贪心\n\n> 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。\n\n- [P1208 [USACO1.3]Mixing Milk](https://www.luogu.com.cn/problem/P1208)\n- [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)\n- [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)\n- [P1199 三国游戏](https://www.luogu.com.cn/problem/P1199)\n- [P2672 推销员](https://www.luogu.com.cn/problem/P2672)\n- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)\n- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)\n- [P5521 [yLOI2019]梅深不见冬](https://www.luogu.com.cn/problem/P5521)\n\n### Part 2.6 构造\n\n> 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。\n\n- [P3599 Koishi Loves Construction](https://www.luogu.com.cn/problem/P3599)\n- [P5441 【XR-2】伤痕](https://www.luogu.com.cn/problem/P5441)\n- [P5595 【XR-4】歌唱比赛](https://www.luogu.com.cn/problem/P5595)\n\n### Part 2.7 高精度\n\n> 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！\n\n- [P1601 A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601)\n- [P2142 高精度减法](https://www.luogu.com.cn/problem/P2142)\n- [P1303 A\\*B Problem](https://www.luogu.com.cn/problem/P1303)\n- [P1480 A/B Problem](https://www.luogu.com.cn/problem/P1480)\n- [P1009 阶乘之和](https://www.luogu.com.cn/problem/P1009)\n\n### Part 2.8 前缀和 & 差分\n\n> 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\n\n- [P3131 [USACO16JAN]Subsequences Summing to Sevens](https://www.luogu.com.cn/problem/P3131)\n- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)\n- [P3397 地毯](https://www.luogu.com.cn/problem/P3397)\n- [P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)\n- [P4552 [Poetize6] IncDec Sequence](https://www.luogu.com.cn/problem/P4552)\n\n\n## Part 3 搜索\n\n> 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。\n\n### Part 3.1 深度优先搜索\n\n> 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。\n>\n> 深度优先搜索一般使用栈来实现。\n\n- [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)\n- [P1019 单词接龙](https://www.luogu.com.cn/problem/P1019)\n- [P5194 [USACO05DEC]Scales](https://www.luogu.com.cn/problem/P5194)\n- [P5440 【XR-2】奇迹](https://www.luogu.com.cn/problem/P5440)\n- [P1378 油滴扩展](https://www.luogu.com.cn/problem/P1378)\n\n### Part 3.2 广度优先搜索\n\n> 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。\n>\n> 广度优先搜索一般使用队列来实现。\n\n- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)\n- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)\n- [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)\n- [P1032 字串变换](https://www.luogu.com.cn/problem/P1032)\n- [P1126 机器人搬重物](https://www.luogu.com.cn/problem/P1126)\n\n### Part 3.3 记忆化搜索\n\n> 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。\n>\n> 动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。\n\n- [P1514 引水入城](https://www.luogu.com.cn/problem/P1514)\n- [P1535 游荡的奶牛](https://www.luogu.com.cn/problem/P1535)\n- [P1434 [SHOI2002]滑雪](https://www.luogu.com.cn/problem/P1434)\n- [P3953 逛公园](https://www.luogu.com.cn/problem/P3953)\n\n### Part 3.4 搜索的剪枝\n\n> 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。\n\n- [P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)\n- [P1312 Mayan游戏](https://www.luogu.com.cn/problem/P1312)\n- [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)\n\n### Part 3.5 双向搜索\n\n> 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。\n\n- [P3067 [USACO12OPEN]Balanced Cow Subsets](https://www.luogu.com.cn/problem/P3067)\n- [P4799 [CEOI2015 Day2]世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)\n- [P5195 [USACO05DEC]Knights of Ni](https://www.luogu.com.cn/problem/P5195)\n\n### Part 3.6 A\\*\n\n> 在 BFS 中，如果能设计一个合理的估价函数，就可以更快扩展到最优解。这就是 A\\*算法。\n\n- [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)\n\n### Part 3.7 IDA\\*\n\n> 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。\n>\n> 再加上一个估价函数来减小搜索量，就是 IDA\\*了。\n\n- [P2324 [SCOI2005]骑士精神](https://www.luogu.com.cn/problem/P2324)\n- [P2534 [AHOI2012]铁盘整理](https://www.luogu.com.cn/problem/P2534)\n\n### Part 3.8 DLX\n\n> 算法 X 是通过回溯法求解精确覆盖问题的算法，而删除列这一操作可以使用舞蹈链加速。\n\n- [P4929 【模板】舞蹈链（DLX）](https://www.luogu.com.cn/problem/P4929)\n- [P4205 [NOI2005]智慧珠游戏](https://www.luogu.com.cn/problem/P4205)\n\n## Part 4 动态规划\n\n> 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。\n\n### Part 4.1 线性动态规划\n\n> 线性动态规划，即具有线性阶段划分的动态规划。\n\n- [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)\n- [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)\n- [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)\n- [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)\n- [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)\n- [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)\n- [P2679 子串](https://www.luogu.com.cn/problem/P2679)\n- [P2501 [HAOI2006]数字序列](https://www.luogu.com.cn/problem/P2501)\n- [P3336 [ZJOI2013]话旧](https://www.luogu.com.cn/problem/P3336)\n- [P3558 [POI2013]BAJ-Bytecomputer](https://www.luogu.com.cn/problem/P3558)\n- [P4158 [SCOI2009]粉刷匠](https://www.luogu.com.cn/problem/P4158)\n- [P5301 [GXOI/GZOI2019]宝牌一大堆](https://www.luogu.com.cn/problem/P5301)\n\n### Part 4.2 背包动态规划\n\n> 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。\n\n- [P1048 采药](https://www.luogu.com.cn/problem/P1048)\n- [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)\n- [P1855 榨取kkksc03](https://www.luogu.com.cn/problem/P1855)\n- [P5020 货币系统](https://www.luogu.com.cn/problem/P5020)\n- [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)\n- [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)\n- [P2946 [USACO09MAR]Cow Frisbee Team](https://www.luogu.com.cn/problem/P2946)\n- [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)\n- [P5322 [BJOI2019]排兵布阵](https://www.luogu.com.cn/problem/P5322)\n- [P5289 [十二省联考2019]皮配](https://www.luogu.com.cn/problem/P5289)\n\n### Part 4.3 区间动态规划\n\n> 区间动态规划一般以区间作为动态规划的阶段。\n\n- [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)\n- [P3146 [USACO16OPEN]248](https://www.luogu.com.cn/problem/P3146)\n- [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)\n- [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)\n- [P4170 [CQOI2007]涂色](https://www.luogu.com.cn/problem/P4170)\n- [P4302 [SCOI2003]字符串折叠](https://www.luogu.com.cn/problem/P4302)\n- [P2466 [SDOI2008]Sue的小球](https://www.luogu.com.cn/problem/P2466)\n\n### Part 4.4 树形动态规划\n\n> 树形动态规划，即在树上进行的动态规划。\n>\n> 因为树的递归性质，树形动态规划一般都是递归求解的。\n\n- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)\n- [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)\n- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)\n- [P1122 最大子树和](https://www.luogu.com.cn/problem/P1122)\n- [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)\n- [P2014 选课](https://www.luogu.com.cn/problem/P2014)\n- [P2585 [ZJOI2006]三色二叉树](https://www.luogu.com.cn/problem/P2585)\n- [P3047 [USACO12FEB]Nearby Cows](https://www.luogu.com.cn/problem/P3047)\n- [P3698 [CQOI2017]小Q的棋盘](https://www.luogu.com.cn/problem/P3698)\n- [P5658 括号树](https://www.luogu.com.cn/problem/P5658)\n- [P2607 [ZJOI2008]骑士](https://www.luogu.com.cn/problem/P2607)\n- [P3177 [HAOI2015]树上染色](https://www.luogu.com.cn/problem/P3177)\n- [P4395 [BOI2003]Gem](https://www.luogu.com.cn/problem/P4395)\n- [P4516 [JSOI2018]潜入行动](https://www.luogu.com.cn/problem/P4516)\n\n### Part 4.5 状态压缩动态规划\n\n> 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。\n\n- [P2704 [NOI2001]炮兵阵地](https://www.luogu.com.cn/problem/P2704)\n- [P1879 [USACO06NOV]Corn Fields](https://www.luogu.com.cn/problem/P1879)\n- [P1896 [SCOI2005]互不侵犯](https://www.luogu.com.cn/problem/P1896)\n- [P3092 [USACO13NOV]No Change](https://www.luogu.com.cn/problem/P3092)\n- [P3694 邦邦的大合唱站队](https://www.luogu.com.cn/problem/P3694)\n- [P4925 [1007]Scarlet的字符串不可能这么可爱](https://www.luogu.com.cn/problem/P4925)\n- [P2157 [SDOI2009]学校食堂](https://www.luogu.com.cn/problem/P2157)\n- [P2167 [SDOI2009]Bill的挑战](https://www.luogu.com.cn/problem/P2167)\n- [P2396 yyy loves Maths VII](https://www.luogu.com.cn/problem/P2396)\n- [P4363 [九省联考2018]一双木棋](https://www.luogu.com.cn/problem/P4363)\n- [P5005 中国象棋 - 摆上马](https://www.luogu.com.cn/problem/P5005)\n- [P2150 [NOI2015]寿司晚宴](https://www.luogu.com.cn/problem/P2150)\n\n### Part 4.6 倍增优化动态规划\n\n> 利用倍增的方式，我们可以将状态转移的效率大大提高。\n\n- [P1613 跑路](https://www.luogu.com.cn/problem/P1613)\n- [P1081 开车旅行](https://www.luogu.com.cn/problem/P1081)\n- [P5024 保卫王国](https://www.luogu.com.cn/problem/P5024)\n\n### Part 4.7 数据结构优化动态规划\n\n> 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。\n\n- [P4719 【模板】动态dp](https://www.luogu.com.cn/problem/P4719)\n- [P4751 动态dp【加强版】](https://www.luogu.com.cn/problem/P4751)\n- [P3287 [SCOI2014]方伯伯的玉米田](https://www.luogu.com.cn/problem/P3287)\n- [P2605 [ZJOI2010]基站选址](https://www.luogu.com.cn/problem/P2605)\n\n### Part 4.8 单调队列优化动态规划\n\n> 借助单调队列，排除不可能的决策，可以起到优化状态转移的效果。\n\n- [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)\n- [P3089 [USACO13NOV]Pogo-Cow](https://www.luogu.com.cn/problem/P3089)\n- [P3572 [POI2014]PTA-Little Bird](https://www.luogu.com.cn/problem/P3572)\n- [P3522 [POI2011]TEM-Temperature](https://www.luogu.com.cn/problem/P3522)\n- [P4544 [USACO10NOV]Buying Feed](https://www.luogu.com.cn/problem/P4544)\n- [P5665 划分](https://www.luogu.com.cn/problem/P5665)\n- [P1973 [NOI2011]Noi嘉年华](https://www.luogu.com.cn/problem/P1973)\n- [P2569 [SCOI2010]股票交易](https://www.luogu.com.cn/problem/P2569)\n- [P4852 yyf hates choukapai](https://www.luogu.com.cn/problem/P4852)\n\n### Part 4.9 斜率优化动态规划\n\n> 通过用单调队列维护一个凸壳，来达到优化转移的目的。\n\n- [P2900 [USACO08MAR]Land Acquisition](https://www.luogu.com.cn/problem/P2900)\n- [P3195 [HNOI2008]玩具装箱](https://www.luogu.com.cn/problem/P3195)\n- [P3628 [APIO2010]特别行动队](https://www.luogu.com.cn/problem/P3628)\n- [P3648 [APIO2014]序列分割](https://www.luogu.com.cn/problem/P3648)\n- [P4027 [NOI2007]货币兑换](https://www.luogu.com.cn/problem/P4027)\n- [P4360 [CEOI2004]锯木厂选址](https://www.luogu.com.cn/problem/P4360)\n- [P5468 [NOI2019]回家路线](https://www.luogu.com.cn/problem/P5468)\n- [P2305 [NOI2014]购票](https://www.luogu.com.cn/problem/P2305)\n\n### Part 4.10 决策单调性优化动态规划\n\n> 利用决策间的递变规律，也能实现优化状态转移的目的。\n\n- [P3515 [POI2011]Lightning Conductor](https://www.luogu.com.cn/problem/P3515)\n- [P4767 [IOI2000]邮局](https://www.luogu.com.cn/problem/P4767)\n- [P1912 [NOI2009]诗人小G](https://www.luogu.com.cn/problem/P1912)\n- [P1973 [NOI2011]Noi嘉年华](https://www.luogu.com.cn/problem/P1973)\n- [P3724 [AH2017/HNOI2017]大佬](https://www.luogu.com.cn/problem/P3724)\n- [P5574 [CmdOI2019]任务分配问题](https://www.luogu.com.cn/problem/P5574)\n\n### Part 4.11 数位统计类动态规划\n\n> 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。\n\n- [P2602 [ZJOI2010]数字计数](https://www.luogu.com.cn/problem/P2602)\n- [P3281 [SCOI2013]数数](https://www.luogu.com.cn/problem/P3281)\n- [P2518 [HAOI2010]计数](https://www.luogu.com.cn/problem/P2518)\n- [P2657 [SCOI2009]windy数](https://www.luogu.com.cn/problem/P2657)\n- [P3286 [SCOI2014]方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286)\n- [P4124 [CQOI2016]手机号码](https://www.luogu.com.cn/problem/P4124)\n- [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)\n- [P2606 [ZJOI2010]排列计数](https://www.luogu.com.cn/problem/P2606)\n- [P4798 [CEOI2015 Day1]卡尔文球锦标赛](https://www.luogu.com.cn/problem/P4798)\n\n### Part 4.12 轮廓线动态规划\n\n> 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。\n\n- [P5056 【模板】插头dp](https://www.luogu.com.cn/problem/P5056)\n- [P2289 [HNOI2004]邮递员](https://www.luogu.com.cn/problem/P2289)\n- [P2337 [SCOI2012]喵星人的入侵](https://www.luogu.com.cn/problem/P2337)\n- [P5347 【XR-1】俄罗斯方块](https://www.luogu.com.cn/problem/P5347)\n\n## Part 5 字符串\n\n> 字符串问题有很多自己的特点。\n\n### Part 5.1 字符串哈希\n\n> 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。\n\n- [P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)\n- [P5270 无论怎样神树大人都会删库跑路](https://www.luogu.com.cn/problem/P5270)\n- [P5537 【XR-3】系统设计](https://www.luogu.com.cn/problem/P5537)\n\n### Part 5.2 KMP\n\n> KMP 算法可以用来解决模式串匹配问题。\n\n- [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)\n- [P4391 [BOI2009]Radio Transmission](https://www.luogu.com.cn/problem/P4391)\n- [P3435 [POI2006]OKR-Periods of Words](https://www.luogu.com.cn/problem/P3435)\n- [P4824 [USACO15FEB]Censoring (Silver)](https://www.luogu.com.cn/problem/P4824)\n- [P2375 [NOI2014]动物园](https://www.luogu.com.cn/problem/P2375)\n- [P3426 [POI2005]SZA-Template](https://www.luogu.com.cn/problem/P3426)\n- [P3193 [HNOI2008]GT考试](https://www.luogu.com.cn/problem/P3193)\n\n### Part 5.3 Manacher\n\n> Manacher 可以在线性时间内求出一个字符串的最长回文子串。\n\n- [P3805 【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)\n- [P4555 [国家集训队]最长双回文串](https://www.luogu.com.cn/problem/P4555)\n- [P1659 [国家集训队]拉拉队排练](https://www.luogu.com.cn/problem/P1659)\n\n### Part 5.4 Trie树\n\n> Trie树可以像查字典一样把多个字符串组织到一棵树上。\n\n- [P3879 [TJOI2010]阅读理解](https://www.luogu.com.cn/problem/P3879)\n- [P2292 [HNOI2004]L语言](https://www.luogu.com.cn/problem/P2292)\n- [P2922 [USACO08DEC]Secret Message](https://www.luogu.com.cn/problem/P2922)\n- [P3065 [USACO12DEC]First!](https://www.luogu.com.cn/problem/P3065)\n- [P3294 [SCOI2016]背单词](https://www.luogu.com.cn/problem/P3294)\n- [P4407 [JSOI2009]电子字典](https://www.luogu.com.cn/problem/P4407)\n- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)\n- [P4683 [IOI2008]Type Printer](https://www.luogu.com.cn/problem/P4683)\n- [P3783 [SDOI2017]天才黑客](https://www.luogu.com.cn/problem/P3783)\n\n### Part 5.5 AC自动机\n\n> AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。\n\n- [P3808 【模板】AC自动机（简单版）](https://www.luogu.com.cn/problem/P3808)\n- [P3796 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3796)\n- [P5357 【模板】AC自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)\n- [P3121 [USACO15FEB]Censoring (Gold)](https://www.luogu.com.cn/problem/P3121)\n- [P2414 [NOI2011]阿狸的打字机](https://www.luogu.com.cn/problem/P2414)\n- [P3966 [TJOI2013]单词](https://www.luogu.com.cn/problem/P3966)\n- [P2444 [POI2000]病毒](https://www.luogu.com.cn/problem/P2444)\n- [P3311 [SDOI2014]数数](https://www.luogu.com.cn/problem/P3311)\n- [P4052 [JSOI2007]文本生成器](https://www.luogu.com.cn/problem/P4052)\n- [P5599 【XR-4】文本编辑器](https://www.luogu.com.cn/problem/P5599)\n\n### Part 5.6 回文自动机\n\n> 回文自动机是解决回文串问题的有力工具。\n\n- [P5496 【模板】回文自动机（PAM）](https://www.luogu.com.cn/problem/P5496)\n- [P3649 [APIO2014]回文串](https://www.luogu.com.cn/problem/P3649)\n- [P4287 [SHOI2011]双倍回文](https://www.luogu.com.cn/problem/solution/P4287)\n- [P4762 [CERC2014]Virus synthesis](https://www.luogu.com.cn/problem/P4762)\n\n### Part 5.7 后缀数组\n\n> 后缀数组可以解决很多字符串匹配的问题。\n\n- [P3809 【模板】后缀排序](https://www.luogu.com.cn/problem/P3809)\n- [P5353 【模板】树上后缀排序](https://www.luogu.com.cn/problem/P5353)\n- [P2336 [SCOI2012]喵星球上的点名](https://www.luogu.com.cn/problem/P2336)\n- [P2463 [SDOI2008]Sandy的卡片](https://www.luogu.com.cn/problem/P2463)\n- [P2852 [USACO06DEC]Milk Patterns](https://www.luogu.com.cn/problem/P2852)\n- [P4051 [JSOI2007]字符加密](https://www.luogu.com.cn/problem/P4051)\n- [P1117 [NOI2016]优秀的拆分](https://www.luogu.com.cn/problem/P1117)\n- [P2178 [NOI2015]品酒大会](https://www.luogu.com.cn/problem/P2178)\n- [P5346 【XR-1】柯南家族](https://www.luogu.com.cn/problem/P5346)\n- [P5576 [CmdOI2019]口头禅](https://www.luogu.com.cn/problem/P5576)\n\n### Part 5.8 后缀自动机\n\n> 后缀自动机是一种处理字符串问题的强大工具。\n\n- [P3804 【模板】后缀自动机](https://www.luogu.com.cn/problem/P3804)\n- [P3649 [APIO2014]回文串](https://www.luogu.com.cn/problem/P3649)\n- [P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)\n- [P4248 [AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)\n- [P5341 [TJOI2019]甲苯先生和大中锋的字符串](https://www.luogu.com.cn/problem/P5341)\n- [P4770 [NOI2018]你的名字](https://www.luogu.com.cn/problem/P4770)\n- [P5284 [十二省联考2019]字符串问题](https://www.luogu.com.cn/problem/P5284)\n- [P5319 [BJOI2019]奥术神杖](https://www.luogu.com.cn/problem/P5319)\n\n## Part 6 数学\n\n> OI 中的数学知识很多，也有些杂乱。\n\n### Part 6.1 位运算\n\n> 将十进制整数转换为二进制后，有很多按位运算的运算符。\n> \n> 如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。\n\n- [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)\n- [P5514 [MtOI2019]永夜的报应](https://www.luogu.com.cn/problem/P5514)\n- [P5538 【XR-3】Namid[A]me](https://www.luogu.com.cn/problem/P5538)\n- [P5539 【XR-3】Unknown Mother-Goose](https://www.luogu.com.cn/problem/P5539)\n- [P5523 [yLOI2019]珍珠](https://www.luogu.com.cn/problem/P5523)\n\n### Part 6.2 整除相关\n\n> 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。\n\n#### Part 6.2.1 素数\n\n> 素数，指的是除 1 和它本身之外没有其他约数的数。\n\n- [P4718 【模板】Pollard-Rho算法](https://www.luogu.com.cn/problem/P4718)\n- [P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)\n- [P2441 角色属性树](https://www.luogu.com.cn/problem/P2441)\n- [P5535 【XR-3】小道消息](https://www.luogu.com.cn/problem/P5535)\n\n#### Part 6.2.2 最大公约数\n\n> 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。\n>\n> 求解两个数的最大公约数，可以采用欧几里得算法解决。\n\n- [P5435 【模板】快速 GCD](https://www.luogu.com.cn/problem/P5435)\n- [P5436 【XR-2】缘分](https://www.luogu.com.cn/problem/P5436)\n- [P1029 最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)\n- [P1414 又是毕业季II](https://www.luogu.com.cn/problem/P1414)\n- [P2152 [SDOI2009]SuperGCD](https://www.luogu.com.cn/problem/P2152)\n- [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)\n\n#### Part 6.2.3 欧拉函数\n\n> 欧拉函数 $ \\varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。\n\n- [P2158 [SDOI2008]仪仗队](https://www.luogu.com.cn/problem/P2158)\n- [P2568 GCD](https://www.luogu.com.cn/problem/P2568)\n- [P2398 GCD SUM](https://www.luogu.com.cn/problem/P2398)\n- [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)\n\n### Part 6.3 同余方程\n\n> 求解同余方程往往可以引出不少话题。\n\n#### Part 6.3.1 线性同余方程&乘法逆元\n\n> 线性同余方程是同余方程中最基础的内容。\n\n- [P4549 【模板】裴蜀定理](https://www.luogu.com.cn/problem/P4549)\n- [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)\n- [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)\n- [P5431 【模板】乘法逆元2](https://www.luogu.com.cn/problem/P5431)\n- [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)\n- [P3951 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)\n- [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)\n\n#### Part 6.3.2 中国剩余定理\n\n> 中国剩余定理可以快速解一元线性同余方程组。\n\n- [P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777)\n- [P3868 [TJOI2009]猜数字](https://www.luogu.com.cn/problem/P3868)\n- [P2480 [SDOI2010]古代猪文](https://www.luogu.com.cn/problem/P2480)\n- [P4774 [NOI2018]屠龙勇士](https://www.luogu.com.cn/problem/P4774)\n- [P5345 【XR-1】快乐肥宅](https://www.luogu.com.cn/problem/P5345)\n\n#### Part 6.3.3 高次同余方程\n\n> BSGS 算法可以高效计算离散对数。\n>\n> 而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。\n\n- [P4195 【模板】exBSGS](https://www.luogu.com.cn/problem/P4195)\n- [P5491 【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)\n- [P3306 [SDOI2013]随机数生成器](https://www.luogu.com.cn/problem/P3306)\n- [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)\n\n### Part 6.4 博弈论\n\n> 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。\n\n- [P2197 【模板】nim游戏](https://www.luogu.com.cn/problem/P2197)\n- [P1288 取数游戏II](https://www.luogu.com.cn/problem/P1288)\n- [P1290 欧几里德的游戏](https://www.luogu.com.cn/problem/P1290)\n- [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)\n- [P2252 取石子游戏](https://www.luogu.com.cn/problem/P2252)\n\n### Part 6.5 概率与期望\n\n> 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。\n\n- [P5104 红包发红包](https://www.luogu.com.cn/problem/P5104)\n- [P1850 换教室](https://www.luogu.com.cn/problem/P1850)\n- [P3830 [SHOI2012]随机树](https://www.luogu.com.cn/problem/P3830)\n- [P4564 [CTSC2018]假面](https://www.luogu.com.cn/problem/P4564)\n- [P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)\n- [P2221 [HAOI2012]高速公路](https://www.luogu.com.cn/problem/P2221)\n- [P3239 [HNOI2015]亚瑟王](https://www.luogu.com.cn/problem/P3239)\n- [P3750 [六省联考2017]分手是祝愿](https://www.luogu.com.cn/problem/P3750)\n- [P4284 [SHOI2014]概率充电器](https://www.luogu.com.cn/problem/P4284)\n- [P5249 [LnOI2019]加特林轮盘赌](https://www.luogu.com.cn/problem/P5249)\n- [P2081 [NOI2012]迷失游乐园](https://www.luogu.com.cn/problem/P2081)\n- [P3343 [ZJOI2015]地震后的幻想乡](https://www.luogu.com.cn/problem/P3343)\n- [P3600 随机数生成器](https://www.luogu.com.cn/problem/P3600)\n- [P5326 [ZJOI2019]开关](https://www.luogu.com.cn/problem/P5326)\n\n### Part 6.6 组合数学\n\n> 组合数学常常与计数问题，概率期望紧密相连。\n\n#### Part 6.6.1 排列组合\n\n> 排列组合是组合数学的基础。\n\n- [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)\n- [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)\n- [P5520 [yLOI2019]青原樱](https://www.luogu.com.cn/problem/P5520)\n- [P3197 [HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)\n- [P2290 [HNOI2004]树的计数](https://www.luogu.com.cn/problem/P2290)\n- [P4981 父子](https://www.luogu.com.cn/problem/P4981)\n- [P4769 [NOI2018]冒泡排序](https://www.luogu.com.cn/problem/P4769)\n- [P4931 情侣？给我烧了！（加强版）](https://www.luogu.com.cn/problem/P4931)\n- [P5596 【XR-4】题](https://www.luogu.com.cn/problem/P5596)\n- [P5598 【XR-4】混乱度](https://www.luogu.com.cn/problem/P5598)\n\n#### Part 6.6.2 卡特兰数&斯特林数\n\n> 卡特兰数和斯特林数是两类常见的组合递推数列。\n\n- [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)\n- [P5396 第二类斯特林数·列](https://www.luogu.com.cn/problem/P5396)\n- [P5408 第一类斯特林数·行](https://www.luogu.com.cn/problem/P5408)\n- [P5409 第一类斯特林数·列](https://www.luogu.com.cn/problem/P5409)\n- [P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)\n- [P2532 [AHOI2012]树屋阶梯](https://www.luogu.com.cn/problem/P2532)\n- [P3200 [HNOI2009]有趣的数列](https://www.luogu.com.cn/problem/P3200)\n- [P3978 [TJOI2015]概率论](https://www.luogu.com.cn/problem/P3978)\n- [P4091 [HEOI2016/TJOI2016]求和](https://www.luogu.com.cn/problem/P4091)\n- [P4827 [国家集训队]Crash 的文明世界](https://www.luogu.com.cn/problem/P4827)\n\n#### Part 6.6.3 容斥原理\n\n> 容斥原理常常用于解决集合的计数问题。\n\n- [P5664 Emiya 家今天的饭](https://www.luogu.com.cn/problem/P5664)\n- [P1450 [HAOI2008]硬币购物](https://www.luogu.com.cn/problem/P1450)\n- [P3214 [HNOI2011]卡农](https://www.luogu.com.cn/problem/P3214)\n- [P3270 [JLOI2016]成绩比较](https://www.luogu.com.cn/problem/P3270)\n- [P4336 [SHOI2016]黑暗前的幻想乡](https://www.luogu.com.cn/problem/P4336)\n- [P4448 [AHOI2018初中组]球球的排列](https://www.luogu.com.cn/problem/P4448)\n- [P4491 [HAOI2018]染色](https://www.luogu.com.cn/problem/P4491)\n- [P5339 [TJOI2019]唱、跳、rap和篮球](https://www.luogu.com.cn/problem/P5339)\n- [P5400 [CTS2019]随机立方体](https://www.luogu.com.cn/problem/P5400)\n\n### Part 6.7 线性代数\n\n> 线性代数主要用于解决线性关系问题。\n\n#### Part 6.7.1 矩阵\n\n> 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。\n\n- [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)\n- [P1939 【模板】矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)\n- [P4783 【模板】矩阵求逆](https://www.luogu.com.cn/problem/P4783)\n- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)\n- [P1349 广义斐波那契数列](https://www.luogu.com.cn/problem/P1349)\n- [P4000 斐波那契数列](https://www.luogu.com.cn/problem/P4000)\n- [P3758 [TJOI2017]可乐](https://www.luogu.com.cn/problem/P3758)\n- [P4967 黑暗打击](https://www.luogu.com.cn/problem/P4967)\n- [P5343 【XR-1】分块](https://www.luogu.com.cn/problem/P5343)\n- [P5337 [TJOI2019]甲苯先生的字符串](https://www.luogu.com.cn/problem/P5337)\n- [P5303 [GXOI/GZOI2019]逼死强迫症](https://www.luogu.com.cn/problem/P5303)\n\n#### Part 6.7.2 高斯消元\n\n> 高斯消元可以用来求解方程组。\n\n- [P3389 【模板】高斯消元法](https://www.luogu.com.cn/problem/P3389)\n- [P2447 [SDOI2010]外星千足虫](https://www.luogu.com.cn/problem/P2447)\n- [P4035 [JSOI2008]球形空间产生器](https://www.luogu.com.cn/problem/P4035)\n- [P5516 [MtOI2019]小铃的烦恼](https://www.luogu.com.cn/problem/P5516)\n- [P4111 [HEOI2015]小Z的房间](https://www.luogu.com.cn/problem/P4111)\n- [P4457 [BJOI2018]治疗之雨](https://www.luogu.com.cn/problem/P4457)\n\n#### Part 6.7.3 线性基\n\n> 线性基可以求解最大异或和的一类问题。\n\n- [P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)\n- [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)\n- [P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)\n- [P4301 [CQOI2013]新Nim游戏](https://www.luogu.com.cn/problem/P4301)\n- [P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)\n- [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)\n\n### Part 6.8 多项式\n\n> 对多项式的运算进行优化，从而能够解决规模更大的问题。\n\n- [P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)\n- [P4238 【模板】多项式求逆](https://www.luogu.com.cn/problem/P4238)\n- [P4245 【模板】任意模数NTT](https://www.luogu.com.cn/problem/P4245)\n- [P4512 【模板】多项式除法](https://www.luogu.com.cn/problem/P4512)\n- [P4717 【模板】快速沃尔什变换](https://www.luogu.com.cn/problem/P4717)\n- [P4721 【模板】分治 FFT](https://www.luogu.com.cn/problem/P4721)\n- [P4725 【模板】多项式对数函数](https://www.luogu.com.cn/problem/P4725)\n- [P4726 【模板】多项式指数函数](https://www.luogu.com.cn/problem/P4726)\n- [P4781 【模板】拉格朗日插值](https://www.luogu.com.cn/problem/P4781)\n- [P5050 【模板】多项式多点求值](https://www.luogu.com.cn/problem/P5050)\n- [P5158 【模板】多项式快速插值](https://www.luogu.com.cn/problem/P5158)\n- [P5205 【模板】多项式开根](https://www.luogu.com.cn/problem/P5205)\n- [P5245 【模板】多项式快速幂](https://www.luogu.com.cn/problem/P5245)\n- [P5273 【模板】多项式幂函数 (加强版)](https://www.luogu.com.cn/problem/P5273)\n- [P5282 【模板】快速阶乘算法](https://www.luogu.com.cn/problem/P5282)\n- [P5373 【模板】多项式复合函数](https://www.luogu.com.cn/problem/P5373)\n- [P5394 【模板】下降幂多项式乘法](https://www.luogu.com.cn/problem/P5394)\n- [P3338 [ZJOI2014]力](https://www.luogu.com.cn/problem/P3338)\n- [P3723 [AH2017/HNOI2017]礼物](https://www.luogu.com.cn/problem/P3723)\n- [P5437 【XR-2】约定](https://www.luogu.com.cn/problem/P5437)\n- [P5293 [HNOI2019]白兔之舞](https://www.luogu.com.cn/problem/P5293)\n- [P5432 A/B Problem (加强版)](https://www.luogu.com.cn/problem/P5432)\n- [P5472 [NOI2019]斗主地](https://www.luogu.com.cn/problem/P5472)\n- [P5577 [CmdOI2019]算力训练](https://www.luogu.com.cn/problem/P5577)\n\n### Part 6.9 莫比乌斯反演\n\n> 运用莫比乌斯反演，我们可以将一些函数转化，从而降低计算难度。\n\n- [P3172 [CQOI2015]选数](https://www.luogu.com.cn/problem/P3172)\n- [P2522 [HAOI2011]Problem b](https://www.luogu.com.cn/problem/P2522)\n- [P3455 [POI2007]ZAP-Queries](https://www.luogu.com.cn/problem/P3455)\n- [P3327 [SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327)\n- [P1829 [国家集训队]Crash的数字表格 / JZPTAB](https://www.luogu.com.cn/problem/P1829)\n- [P4619 [SDOI2018]旧试题](https://www.luogu.com.cn/problem/P4619)\n- [P3704 [SDOI2017]数字表格](https://www.luogu.com.cn/problem/P3704)\n- [P5518 [MtOI2019]幽灵乐团](https://www.luogu.com.cn/problem/P5518)\n\n### Part 6.10 筛法\n\n> 利用数列的性质，有多种筛法可以求出我们想要的信息。\n\n- [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)\n- [P4213 【模板】杜教筛（Sum）](https://www.luogu.com.cn/problem/P4213)\n- [P5325 【模板】Min_25筛](https://www.luogu.com.cn/problem/P5325)\n- [P1865 A % B Problem](https://www.luogu.com.cn/problem/P1865)\n- [P1621 集合](https://www.luogu.com.cn/problem/P1621)\n- [P3768 简单的数学题](https://www.luogu.com.cn/problem/P3768)\n- [P5438 【XR-2】记忆](https://www.luogu.com.cn/problem/P5438)\n\n### Part 6.11 线性规划\n\n> 线性规划是研究线性约束条件下线性目标函数极值问题的方法。\n\n- [P3980 [NOI2008]志愿者招募](https://www.luogu.com.cn/problem/P3980)\n- [P4232 无意识之外的捉迷藏](https://www.luogu.com.cn/problem/P4232)\n\n### Part 6.12 数值方法\n\n> 在算法领域，有很多求近似值的数值方法。\n\n#### Part 6.12.1 三分法\n\n> 三分法可以求出一个单峰 / 单谷函数的极值。\n\n- [P3382 【模板】三分法](https://www.luogu.com.cn/problem/P3382)\n- [P1883 函数](https://www.luogu.com.cn/problem/P1883)\n\n#### Part 6.12.2 自适应辛普森法\n\n> 自适应辛普森法可以高效求出给定函数的数值积分。\n\n- [P4525 【模板】自适应辛普森法1](https://www.luogu.com.cn/problem/P4525)\n- [P4526 【模板】自适应辛普森法2](https://www.luogu.com.cn/problem/P4526)\n- [P3779 [SDOI2017]龙与地下城](https://www.luogu.com.cn/problem/P3779)\n\n### Part 6.13 置换群\n\n> 置换群通常用来解决一些涉及“本质不同”的计数问题。\n\n- [P4980 【模板】Polya定理](https://www.luogu.com.cn/problem/P4980)\n- [P1446 [HNOI2008]Cards](https://www.luogu.com.cn/problem/P1446)\n- [P2561 [AHOI2002]黑白瓷砖](https://www.luogu.com.cn/problem/P2561)\n- [P4128 [SHOI2006]有色图](https://www.luogu.com.cn/problem/P4128)\n- [P4727 [HNOI2009]图的同构记数](https://www.luogu.com.cn/problem/P4727)\n\n## Part 7 数据结构\n\n> 灵活地运用数据结构可以高效地查询并处理需要的信息。\n\n### Part 7.1 链表\n\n> 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。\n\n- [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)\n- [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)\n\n### Part 7.2 栈\n\n> 栈，是一种后进先出（FILO）的数据结构。\n\n- [P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)\n- [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)\n- [P1981 表达式求值](https://www.luogu.com.cn/problem/P1981)\n- [P1175 表达式的转换](https://www.luogu.com.cn/problem/P1175)\n\n### Part 7.3 队列\n\n> 队列，是一种先进先出（FIFO）的数据结构。\n\n- [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540)\n\n### Part 7.4 并查集\n\n> 并查集常用于处理一些不相交集合的合并和查询问题。\n\n- [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)\n- [P3958 奶酪](https://www.luogu.com.cn/problem/P3958)\n- [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)\n- [P4185 [USACO18JAN]MooTube G](https://www.luogu.com.cn/problem/P4185)\n- [P2024 [NOI2001]食物链](https://www.luogu.com.cn/problem/P2024)\n- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)\n- [P1196 [NOI2002]银河英雄传说](https://www.luogu.com.cn/problem/P1196)\n- [P1955 [NOI2015]程序自动分析](https://www.luogu.com.cn/problem/P1955)\n\n### Part 7.5 二叉堆\n\n> 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。\n\n- [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)\n- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)\n- [P1168 中位数](https://www.luogu.com.cn/problem/P1168)\n- [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)\n- [P2827 蚯蚓](https://www.luogu.com.cn/problem/P2827)\n- [P3045 [USACO12FEB]Cow Coupons](https://www.luogu.com.cn/problem/P3045)\n\n### Part 7.6 ST表\n\n> ST表可以离线查询区间最值。\n\n- [P3865 【模板】ST表](https://www.luogu.com.cn/problem/P3865)\n- [P2251 质量检测](https://www.luogu.com.cn/problem/P2251)\n- [P1816 忠诚](https://www.luogu.com.cn/problem/P1816)\n- [P1198 [JSOI2008]最大数](https://www.luogu.com.cn/problem/P1198)\n- [P2880 [USACO07JAN]Balanced Lineup](https://www.luogu.com.cn/problem/P2880)\n- [P5012 水の数列](https://www.luogu.com.cn/problem/P5012)\n- [P5344 【XR-1】逛森林](https://www.luogu.com.cn/problem/P5344)\n- [P2048 [NOI2010]超级钢琴](https://www.luogu.com.cn/problem/P2048)\n\n### Part 7.7 树状数组\n\n> 树状数组是一种简洁高效的树形数据结构。\n\n- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)\n- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)\n- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)\n- [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)\n- [P3605 [USACO17JAN]Promotion Counting](https://www.luogu.com.cn/problem/P3605)\n- [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)\n- [P3586 [POI2015]LOG](https://www.luogu.com.cn/problem/P3586)\n- [P4054 [JSOI2009]计数问题](https://www.luogu.com.cn/problem/P4054)\n- [P4113 [HEOI2012]采花](https://www.luogu.com.cn/problem/P4113)\n- [P3960 列队](https://www.luogu.com.cn/problem/P3960)\n\n### Part 7.8 线段树\n\n> 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。\n\n- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)\n- [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)\n- [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)\n- [P4588 [TJOI2018]数学计算](https://www.luogu.com.cn/problem/P4588)\n- [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502)\n- [P2471 [SCOI2007]降雨量](https://www.luogu.com.cn/problem/P2471)\n- [P2824 [HEOI2016/TJOI2016]排序](https://www.luogu.com.cn/problem/P2824)\n- [P3722 [AH2017/HNOI2017]影魔](https://www.luogu.com.cn/problem/P3722)\n- [P4097 [HEOI2013]Segment](https://www.luogu.com.cn/problem/P4097)\n- [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)\n- [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)\n- [P4556 [Vani有约会]雨天的尾巴](https://www.luogu.com.cn/problem/P4556)\n- [P5324 [BJOI2019]删数](https://www.luogu.com.cn/problem/P5324)\n- [P5327 [ZJOI2019]语言](https://www.luogu.com.cn/problem/P5327)\n\n### Part 7.9 分块\n\n> 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。\n\n- [P3870 [TJOI2009]开关](https://www.luogu.com.cn/problem/P3870)\n- [P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396)\n- [P3863 序列](https://www.luogu.com.cn/problem/P3863)\n- [P1975 [国家集训队]排队](https://www.luogu.com.cn/problem/P1975)\n- [P3710 方方方的数据结构](https://www.luogu.com.cn/problem/P3710)\n- [P3992 [BJOI2017]开车](https://www.luogu.com.cn/problem/P3992)\n- [P4168 [Violet]蒲公英](https://www.luogu.com.cn/problem/P4168)\n- [P4119 [Ynoi2018]未来日记](https://www.luogu.com.cn/problem/P4119)\n\n### Part 7.10 可并堆\n\n> 可并堆分为左偏树和配对堆两种，它们都具有堆的性质，且可以高效合并。\n\n- [P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)\n- [P2713 罗马游戏](https://www.luogu.com.cn/problem/P2713)\n- [P1456 Monkey King](https://www.luogu.com.cn/problem/P1456)\n- [P1552 [APIO2012]派遣](https://www.luogu.com.cn/problem/P1552)\n- [P3261 [JLOI2015]城池攻占](https://www.luogu.com.cn/problem/P3261)\n- [P3273 [SCOI2011]棘手的操作](https://www.luogu.com.cn/problem/P3273)\n- [P4331 [BOI2004]Sequence](https://www.luogu.com.cn/problem/P4331)\n\n### Part 7.11 主席树\n\n> 主席树，即可持久化权值线段树。\n\n- [P2468 [SDOI2010]粟粟的书架](https://www.luogu.com.cn/problem/P2468)\n- [P3302 [SDOI2013]森林](https://www.luogu.com.cn/problem/P3302)\n- [P3168 [CQOI2015]任务查询系统](https://www.luogu.com.cn/problem/P3168)\n- [P4559 [JSOI2018]列队](https://www.luogu.com.cn/problem/P4559)\n- [P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633)\n- [P3293 [SCOI2016]美味](https://www.luogu.com.cn/problem/P3293)\n- [P4618 [SDOI2018]原题识别](https://www.luogu.com.cn/problem/P4618)\n\n### Part 7.12 平衡树\n\n> 二叉搜索树可以用来维护有序序列。\n>\n> 为了保证查询效率，有多种使二叉搜索树保持平衡的实现方法。\n\n- [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)\n- [P3391 【模板】文艺平衡树（Splay）](https://www.luogu.com.cn/problem/P3391)\n- [P3850 [TJOI2007]书架](https://www.luogu.com.cn/problem/P3850)\n- [P4008 [NOI2003]文本编辑器](https://www.luogu.com.cn/problem/P4008)\n- [P5338 [TJOI2019]甲苯先生的滚榜](https://www.luogu.com.cn/problem/P5338)\n- [P2042 [NOI2005]维护数列](https://www.luogu.com.cn/problem/P2042)\n- [P1110 [ZJOI2007]报表统计](https://www.luogu.com.cn/problem/P1110)\n- [P3644 [APIO2015]八邻旁之桥](https://www.luogu.com.cn/problem/P3644)\n- [P1486 [NOI2004]郁闷的出纳员](https://www.luogu.com.cn/problem/P1486)\n- [P2710 数列](https://www.luogu.com.cn/problem/P2710)\n- [P3224 [HNOI2012]永无乡](https://www.luogu.com.cn/problem/P3224)\n- [P3285 [SCOI2014]方伯伯的OJ](https://www.luogu.com.cn/problem/P3285)\n- [P5321 [BJOI2019]送别](https://www.luogu.com.cn/problem/P5321)\n\n### Part 7.13 树链剖分\n\n> 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。\n\n- [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)\n- [P3313 [SDOI2014]旅行](https://www.luogu.com.cn/problem/P3313)\n- [P2590 [ZJOI2008]树的统计](https://www.luogu.com.cn/problem/P2590)\n- [P1505 [国家集训队]旅游](https://www.luogu.com.cn/problem/P1505)\n- [P2486 [SDOI2011]染色](https://www.luogu.com.cn/problem/P2486)\n- [P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)\n- [P4069 [SDOI2016]游戏](https://www.luogu.com.cn/problem/P4069)\n- [P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211)\n- [P4592 [TJOI2018]异或](https://www.luogu.com.cn/problem/P4592)\n- [P5305 [GXOI/GZOI2019]旧词](https://www.luogu.com.cn/problem/P5305)\n- [P5354 [Ynoi2017]由乃的OJ](https://www.luogu.com.cn/problem/P5354)\n- [P5499 [LnOI2019]Abbi并不想研学](https://www.luogu.com.cn/problem/P5499)\n\n### Part 7.14 树套树\n\n> 树套树可以用来维护多维度信息。\n\n- [P3380 【模板】二逼平衡树（树套树）](https://www.luogu.com.cn/problem/P3380)\n- [P1975 [国家集训队]排队](https://www.luogu.com.cn/problem/P1975)\n- [P3332 [ZJOI2013]K大数查询](https://www.luogu.com.cn/problem/P3332)\n- [P4278 带插入区间K小值](https://www.luogu.com.cn/problem/P4278)\n- [P1903 [国家集训队]数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)\n- [P3759 [TJOI2017]不勤劳的图书管理员](https://www.luogu.com.cn/problem/P3759)\n- [P3242 [HNOI2015]接水果](https://www.luogu.com.cn/problem/P3242)\n- [P3248 [HNOI2016]树](https://www.luogu.com.cn/problem/P3248)\n- [P5445 [APIO2019]路灯](https://www.luogu.com.cn/problem/P5445)\n\n### Part 7.15 动态树\n\n> Link-Cut Tree 可以用来解决动态树一类问题。\n\n- [P3690 【模板】Link Cut Tree （动态树）](https://www.luogu.com.cn/problem/P3690)\n- [P3203 [HNOI2010]弹飞绵羊](https://www.luogu.com.cn/problem/P3203)\n- [P4338 [ZJOI2018]历史](https://www.luogu.com.cn/problem/P4338)\n- [P4312 [COCI2009]OTOCI](https://www.luogu.com.cn/problem/P4312)\n- [P1501 [国家集训队]Tree II](https://www.luogu.com.cn/problem/P1501)\n- [P2387 [NOI2014]魔法森林](https://www.luogu.com.cn/problem/P2387)\n- [P3348 [ZJOI2016]大森林](https://www.luogu.com.cn/problem/P3348)\n- [P3703 [SDOI2017]树点涂色](https://www.luogu.com.cn/problem/P3703)\n- [P4172 [WC2006]水管局长](https://www.luogu.com.cn/problem/P4172)\n- [P4219 [BJOI2014]大融合](https://www.luogu.com.cn/problem/P4219)\n- [P5489 EntropyIncreaser 与 动态图](https://www.luogu.com.cn/problemnew/solution/P5489)\n\n### Part 7.16 可持久化数据结构\n\n> 可持久化数据结构实现了在更新信息的时候保留历史版本。\n\n- [P3919 【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)\n- [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)\n- [P3402 【模板】可持久化并查集](https://www.luogu.com.cn/problem/P3402)\n- [P3835 【模板】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)\n- [P5055 【模板】可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055)\n- [P5283 [十二省联考2019]异或粽子](https://www.luogu.com.cn/problem/P5283)\n\n### Part 7.17 K-D Tree\n\n> K-D Tree 是一种高效处理 $ k $ 维信息的数据结构。\n\n- [P4357 [CQOI2016]K远点对](https://www.luogu.com.cn/problem/P4357)\n- [P4148 简单题](https://www.luogu.com.cn/problem/P4148)\n- [P2479 [SDOI2010]捉迷藏](https://www.luogu.com.cn/problem/P2479)\n- [P3769 [CH弱省胡策R2]TATT](https://www.luogu.com.cn/problem/P3769)\n- [P4169 [Violet]天使玩偶/SJY摆棋子](https://www.luogu.com.cn/problem/P4169)\n- [P4390 [BOI2007]Mokia](https://www.luogu.com.cn/problem/P4390)\n- [P4475 巧克力王国](https://www.luogu.com.cn/problem/P4475)\n- [P2093 [国家集训队]JZPFAR](https://www.luogu.com.cn/problem/P2093)\n- [P5471 [NOI2019]弹跳](https://www.luogu.com.cn/problem/P5471)\n\n### Part 7.18 珂朵莉树\n\n> 珂朵莉树，是一种基于 `std::set` 的暴力数据结构，在数据随机的情况下表现优秀。\n\n- [P5251 [LnOI2019]第二代图灵机](https://www.luogu.com.cn/problem/P5251)\n- [P5350 序列](https://www.luogu.com.cn/problem/P5350)\n\n## Part 8 图论\n\n> 图论是数学的一个分支，它以图为研究的对象。\n\n### Part 8.1 图的存储与遍历\n\n> 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。\n\n- [P2661 信息传递](https://www.luogu.com.cn/problem/P2661)\n- [P2921 [USACO08DEC]Trick or Treat on the Farm](https://www.luogu.com.cn/problem/P2921)\n\n### Part 8.2 最短路问题\n\n> 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。\n\n- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)\n- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)\n- [P5905 【模板】Johnson 全源最短路](https://www.luogu.com.cn/problem/P5905)\n- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)\n- [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)\n- [P1522 Cow Tours](https://www.luogu.com.cn/problem/P1522)\n- [P1266 速度限制](https://www.luogu.com.cn/problem/P1266)\n- [P4001 [ICPC-Beijing 2006]狼抓兔子](https://www.luogu.com.cn/problem/P4001)\n- [P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568)\n- [P3238 [HNOI2014]道路堵塞](https://www.luogu.com.cn/problem/P3238)\n- [P5304 [GXOI/GZOI2019]旅行者](https://www.luogu.com.cn/problem/P5304)\n\n### Part 8.3 树上问题\n\n> 作为一种特殊的图，树上的问题具有很多鲜明的特点。\n\n#### Part 8.3.1 二叉树\n\n> 二叉树是一种特殊的树，它有很多特殊的性质。\n>\n\n- [P1087 FBI树](https://www.luogu.com.cn/problem/P1087)\n- [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)\n- [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)\n- [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)\n- [P5018 对称二叉树](https://www.luogu.com.cn/problem/P5018)\n- [P5597 【XR-4】复读](https://www.luogu.com.cn/problem/P5597)\n\n#### Part 8.3.2 树的直径\n\n> 树的直径被定义为树上最远的两点间的距离。\n>\n> 计算树的直径，可以通过两遍 DFS 解决。\n\n- [P2195 HXY造公园](https://www.luogu.com.cn/problem/P2195)\n- [P3629 [APIO2010]巡逻](https://www.luogu.com.cn/problem/P3629)\n- [P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)\n- [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)\n- [P4408 [NOI2003]逃学的小孩](https://www.luogu.com.cn/problem/P4408)\n\n#### Part 8.3.3 最近公共祖先\n\n> 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。\n>\n> 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。\n\n- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)\n- [P3938 斐波那契](https://www.luogu.com.cn/problem/P3938)\n- [P4281 [AHOI2008]紧急集合 / 聚会](https://www.luogu.com.cn/problem/P4281)\n\n### Part 8.4 生成树\n\n> 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。\n\n- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)\n- [P4180 【模板】严格次小生成树[BJWC2010]](https://www.luogu.com.cn/problem/P4180)\n- [P2872 [USACO07DEC]Building Roads](https://www.luogu.com.cn/problem/P2872)\n- [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)\n- [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)\n- [P4047 [JSOI2010]部落划分](https://www.luogu.com.cn/problem/P4047)\n\n### Part 8.5 拓扑排序\n\n> 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。\n\n- [P1113 杂务](https://www.luogu.com.cn/problem/P1113)\n- [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)\n- [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)\n\n### Part 8.6 差分约束\n\n> 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。 \n\n- [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)\n- [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)\n- [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)\n- [P4926 [1007]倍杀测量者](https://www.luogu.com.cn/problem/P4926)\n- [P5590 赛车游戏](https://www.luogu.com.cn/problem/P5590)\n\n### Part 8.7 图的连通性相关\n\n> 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。\n\n- [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)\n- [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)\n- [P2341 [HAOI2006]受欢迎的牛](https://www.luogu.com.cn/problem/P2341)\n- [P2863 [USACO06JAN]The Cow Prom](https://www.luogu.com.cn/problem/P2863)\n- [P2746 [USACO5.3]Network of Schools](https://www.luogu.com.cn/problem/P2746)\n- [P1407 [国家集训队]稳定婚姻](https://www.luogu.com.cn/problem/P1407)\n- [P2272 [ZJOI2007]最大半连通子图](https://www.luogu.com.cn/problem/P2272)\n- [P3225 [HNOI2012]矿场搭建](https://www.luogu.com.cn/problem/P3225)\n- [P5058 [ZJOI2004]嗅探器](https://www.luogu.com.cn/problem/P5058)\n- [P2515 [HAOI2010]软件安装](https://www.luogu.com.cn/problem/P2515)\n\n### Part 8.8 二分图\n\n> 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。\n\n- [P3386 【模板】二分图匹配](https://www.luogu.com.cn/problem/P3386)\n- [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)\n- [P1129 [ZJOI2007]矩阵游戏](https://www.luogu.com.cn/problem/P1129)\n- [P1559 运动员最佳匹配问题](https://www.luogu.com.cn/problem/P1559)\n- [P2423 [HEOI2012]朋友圈](https://www.luogu.com.cn/problem/P2423)\n- [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)\n- [P2825 [HEOI2016/TJOI2016]游戏](https://www.luogu.com.cn/problem/P2825)\n- [P3033 [USACO11NOV]Cow Steeplechase](https://www.luogu.com.cn/problem/P3033)\n- [P3731 [HAOI2017]新型城市化](https://www.luogu.com.cn/problem/P3731)\n- [P4014 分配问题](https://www.luogu.com.cn/problem/P4014)\n- [P4617 [COCI2017-2018#5] Planinarenje](https://www.luogu.com.cn/problem/P4617)\n\n### Part 8.9 网络流\n\n> 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。\n\n#### Part 8.9.1 最大流\n\n> 最大流，即求网络中最大的流量。\n\n- [P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)\n- [P4722 【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)\n- [P2065 [TJOI2011]卡片](https://www.luogu.com.cn/problem/P2065)\n- [P2763 试题库问题](https://www.luogu.com.cn/problem/P2763)\n- [P2472 [SCOI2007]蜥蜴](https://www.luogu.com.cn/problem/P2472)\n- [P2754 [CTSC1999]家园](https://www.luogu.com.cn/problem/P2754)\n- [P2765 魔术球问题](https://www.luogu.com.cn/problem/P2765)\n- [P2766 最长不下降子序列问题](https://www.luogu.com.cn/problem/P2766)\n- [P2805 [NOI2009]植物大战僵尸](https://www.luogu.com.cn/problem/P2805)\n- [P3749 [六省联考2017]寿司餐厅](https://www.luogu.com.cn/problem/P3749)\n\n#### Part 8.9.2 最小割\n\n> 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。\n>\n> 可以证明，**最大流=最小割**。\n\n- [P1344 [USACO4.4]Pollutant Control](https://www.luogu.com.cn/problem/P1344)\n- [P1345 [USACO5.4]Telecowmunication](https://www.luogu.com.cn/problem/P1345)\n- [P2057 [SHOI2007]善意的投票](https://www.luogu.com.cn/problem/P2057)\n- [P2598 [ZJOI2009]狼和羊的故事](https://www.luogu.com.cn/problem/P2598)\n- [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)\n- [P4126 [AHOI2009]最小割](https://www.luogu.com.cn/problem/P4126)\n- [P5039 [SHOI2010]最小生成树](https://www.luogu.com.cn/problem/P5039)\n\n#### Part 8.9.3 费用流\n\n> 在网络流中给边加上一个参数——费用，就出现了费用流。\n\n- [P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381)\n- [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)\n- [P4452 [国家集训队]航班安排](https://www.luogu.com.cn/problem/P4452)\n- [P2045 方格取数加强版](https://www.luogu.com.cn/problem/P2045)\n- [P2050 [NOI2012]美食节](https://www.luogu.com.cn/problem/P2050)\n- [P2053 [SCOI2007]修车](https://www.luogu.com.cn/problem/P2053)\n- [P2604 [ZJOI2010]网络扩容](https://www.luogu.com.cn/problem/P2604)\n- [P2770 航空路线问题](https://www.luogu.com.cn/problem/P2770)\n- [P3159 [CQOI2012]交换棋子](https://www.luogu.com.cn/problem/P3159)\n- [P3356 火星探险问题](https://www.luogu.com.cn/problem/P3356)\n- [P3358 最长k可重区间集问题](https://www.luogu.com.cn/problem/P3358)\n- [P4013 数字梯形问题](https://www.luogu.com.cn/problem/P4013)\n- [P4015 运输问题](https://www.luogu.com.cn/problem/P4015)\n- [P5331 [SNOI2019]通信](https://www.luogu.com.cn/problem/P5331)\n\n#### Part 8.9.4 上下界网络流\n\n> 在网络流问题中给每条边的流量增加一个下界，就有了上下界网络流。\n\n- [P3980 [NOI2008]志愿者招募](https://www.luogu.com.cn/problem/P3980)\n- [P4043 [AHOI2014/JSOI2014]支线剧情](https://www.luogu.com.cn/problem/P4043)\n- [P4553 80人环游世界](https://www.luogu.com.cn/problem/P4553)\n- [P4843 清理雪道](https://www.luogu.com.cn/problem/P4843)\n\n### Part 8.10 2-SAT\n\n> k-SAT 问题的目标是对一些布尔变量赋值，满足限定的条件。\n>\n> 在 k-SAT 问题中，2-SAT 问题属于较为容易解决的一类。\n\n- [P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782)\n- [P4171 [JSOI2010]满汉全席](https://www.luogu.com.cn/problem/P4171)\n- [P3825 [NOI2017]游戏](https://www.luogu.com.cn/problem/P3825)\n- [P5332 [JSOI2019]精准预测](https://www.luogu.com.cn/problem/P5332)\n\n### Part 8.11 点分治\n\n> 点分治是一种可以高效统计树上路径信息的算法。\n\n- [P3806 【模板】点分治1](https://www.luogu.com.cn/problem/P3806)\n- [P2634 [国家集训队]聪聪可可](https://www.luogu.com.cn/problem/P2634)\n- [P2664 树上游戏](https://www.luogu.com.cn/problem/P2664)\n- [P3714 [BJOI2017]树的难题](https://www.luogu.com.cn/problem/P3714)\n- [P4149 [IOI2011]Race](https://www.luogu.com.cn/problem/P4149)\n- [P3241 [HNOI2015]开店](https://www.luogu.com.cn/problem/P3241)\n- [P4075 [SDOI2016]模式字符串](https://www.luogu.com.cn/problem/P4075)\n- [P4183 [USACO18JAN]Cow at Large P](https://www.luogu.com.cn/problem/P4183)\n- [P4292 [WC2010]重建计划](https://www.luogu.com.cn/problem/P4292)\n- [P5306 [COCI2019]Transport](https://www.luogu.com.cn/problem/P5306)\n\n### Part 8.12 虚树\n\n> 将一些无用的点从树上删去，从而达到降低树的规模的效果。\n\n- [P2495 [SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495)\n- [P3233 [HNOI2014]世界树](https://www.luogu.com.cn/problem/P3233)\n- [P5360 [SDOI2019]世界地图](https://www.luogu.com.cn/problem/P5360)\n- [P5439 【XR-2】永恒](https://www.luogu.com.cn/problem/P5439)\n\n### Part 8.13 矩阵树定理\n\n> 矩阵树定理可以解决图的生成树计数问题。\n\n- [P4111 [HEOI2015]小Z的房间](https://www.luogu.com.cn/problem/P4111)\n- [P2144 [FJOI2007]轮状病毒](https://www.luogu.com.cn/problem/P2144)\n- [P3317 [SDOI2014]重建](https://www.luogu.com.cn/problem/P3317)\n- [P4208 [JSOI2008]最小生成树计数](https://www.luogu.com.cn/problem/P4208)\n\n## Part 9 计算几何\n\n> 试着用计算机来解决几何问题吧！\n\n### Part 9.1 凸包\n\n> 凸包指在平面上能包含所有给定点的最小凸多边形。\n\n- [P2742 【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)\n- [P2287 [HNOI2004]最佳包裹](https://www.luogu.com.cn/problem/P2287)\n- [P3829 [SHOI2012]信用卡凸包](https://www.luogu.com.cn/problem/P3829)\n- [P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗?](https://www.luogu.com.cn/problem/P4680)\n- [P4557 [JSOI2018]战争](https://www.luogu.com.cn/problem/P4557)\n- [P5403 [CTS2019]田野](https://www.luogu.com.cn/problem/P5403)\n\n### Part 9.2 旋转卡壳\n\n> 旋转卡壳是一种求出凸包所有对踵点对的算法。\n\n- [P1452 Beauty Contest](https://www.luogu.com.cn/problem/P1452)\n- [P3187 [HNOI2007]最小矩形覆盖](https://www.luogu.com.cn/problem/P3187)\n\n### Part 9.3 半平面交\n\n> 多个半平面的交集称之为半平面交。\n\n- [P3256 [JLOI2013]赛车](https://www.luogu.com.cn/problem/P3256)\n- [P2600 [ZJOI2008]瞭望塔](https://www.luogu.com.cn/problem/P2600)\n- [P4196 [CQOI2006]凸多边形](https://www.luogu.com.cn/problem/P4196)\n- [P3297 [SDOI2013]逃考](https://www.luogu.com.cn/problem/P3297)\n- [P4250 [SCOI2015]小凸想跑步](https://www.luogu.com.cn/problem/P4250)\n- [P5328 [ZJOI2019]浙江省选](https://www.luogu.com.cn/problem/P5328)\n\n## Part 10 杂项\n\n> 这里的专题，有很多都难以纳入前面的类别中，故将他们单独列入了杂项。\n\n### Part 10.1 模拟退火\n\n> 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。\n\n- [P1337 [JSOI2004]平衡点 / 吊打XXX](https://www.luogu.com.cn/problem/P1337)\n- [P2503 [HAOI2006]均分数据](https://www.luogu.com.cn/problem/P2503)\n- [P3878 [TJOI2010]分金币](https://www.luogu.com.cn/problem/P3878)\n\n### Part 10.2 0/1 分数规划\n\n> 0/1 分数规划用来求一个分式的极值。\n\n- [P4377 [USACO18OPEN]Talent Show](https://www.luogu.com.cn/problem/P4377)\n- [P3199 [HNOI2009]最小圈](https://www.luogu.com.cn/problem/P3199)\n- [P3288 [SCOI2014]方伯伯运椰子](https://www.luogu.com.cn/problem/P3288)\n- [P3705 [SDOI2017]新生舞会](https://www.luogu.com.cn/problem/P3705)\n- [P4322 [JSOI2016]最佳团体](https://www.luogu.com.cn/problem/P4322)\n\n### Part 10.3 离线算法\n\n> 当题目不要求强制在线时，我们可以一次性读入所有询问来处理。\n\n#### Part 10.3.1 CDQ 分治\n\n> CDQ 分治是一个基于分治思想的离线算法。\n\n- [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)\n- [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)\n- [P2487 [SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)\n- [P4690 [Ynoi2016]镜中的昆虫](https://www.luogu.com.cn/problem/P4690)\n- [P3206 [HNOI2010]城市建设](https://www.luogu.com.cn/problem/P3206)\n\n#### Part 10.3.2 整体二分\n\n> 整体二分，顾名思义就是把多个查询一起二分解决。\n\n- [P1527 [国家集训队]矩阵乘法](https://www.luogu.com.cn/problem/P1527)\n- [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)\n- [P3527 [POI2011]MET-Meteors](https://www.luogu.com.cn/problem/P3527)\n- [P4602 [CTSC2018]混合果汁](https://www.luogu.com.cn/problem/P4602)\n\n#### Part 10.3.3 莫队\n\n> 莫队算法可以解决不少离线区间询问问题。\n\n- [P1494 [国家集训队]小Z的袜子 /【模板】莫队](https://www.luogu.com.cn/problem/P1494)\n- [P1903 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队](https://www.luogu.com.cn/problem/P1903)\n- [P5906 【模板】回滚莫队](https://www.luogu.com.cn/problem/P5906)\n- [P4887 【模板】莫队二次离线（第十四分块(前体)）](https://www.luogu.com.cn/problem/P4887)\n- [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)\n- [P3674 小清新人渣的本愿](https://www.luogu.com.cn/problem/P3674)\n- [P3709 大爷的字符串题](https://www.luogu.com.cn/problem/P3709)\n- [P4074 [WC2013]糖果公园](https://www.luogu.com.cn/problem/P4074)\n- [P5501 [LnOI2019]来者不拒，去者不追](https://www.luogu.com.cn/problem/P5501)\n\n### Part 10.4 奇怪的题目\n\n> OI 界中有一些非常规套路的题目，这里放出来分享。\n\n- [P4920 [WC2015]未来程序](https://www.luogu.com.cn/problem/P4920)\n- [P5042 [国家集训队]丢失的题面（ydc的题面）](https://www.luogu.com.cn/problem/P5042)\n- [P5285 [十二省联考2019]骗分过样例](https://www.luogu.com.cn/problem/P5285)\n- [P5246 [集训队互测2016]消失的源代码](https://www.luogu.com.cn/problem/P5246)\n\n### Part 10.5 非传统题\n\n> 在 NOI 等比赛中，非传统题正越来越频繁出现。\n>\n> 非传统题主要包括以下几类：提交答案题，交互题，通信题。\n\n#### Part 10.5.1 提交答案题\n\n> 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。\n\n- [P1335 [NOI2013]小Q的修炼](https://www.luogu.com.cn/problem/P1335)\n- [P1737 [NOI2016]旷野大计算](https://www.luogu.com.cn/problem/P1737)\n- [P3614 yyy棋 II](https://www.luogu.com.cn/problem/P3614)\n- [P3640 [APIO2013]出题人](https://www.luogu.com.cn/problem/P3640)\n- [P3782 [WC2017]排序](https://www.luogu.com.cn/problem/P3782)\n- [P3836 Nowruz](https://www.luogu.com.cn/problem/P3836)\n- [P4920 [WC2015]未来程序](https://www.luogu.com.cn/problem/P4920)\n- [P5402 [CTS2019]无处安放](https://www.luogu.com.cn/problem/P5402)\n- [P5418 [CTSC2016]NOIP十合一](https://www.luogu.com.cn/problem/P5418)\n- [P5600 【XR-4】尺规作图](https://www.luogu.com.cn/problem/P5600)\n\n#### Part 10.5.2 交互题\n\n> 在交互题中，选手程序需要通过与测评程序交互来完成任务。\n\n- [P1733 猜数（IO交互版）](https://www.luogu.com.cn/problem/P1733)\n- [P1947 猜数](https://www.luogu.com.cn/problem/P1947)\n- [P5208 [WC2019]I 君的商店](https://www.luogu.com.cn/problem/P5208)\n- [P5473 [NOI2019]I 君的探险](https://www.luogu.com.cn/problem/P5473)\n- [P6541 [WC2018]即时战略](https://www.luogu.com.cn/problem/P6541)\n- [P6558 [APIO2017]考拉的游戏](https://www.luogu.com.cn/problem/P6558)\n\n","tags":["题单"],"categories":["题单"]},{"title":"P2014 [CTSC1997] 选课","url":"/2022/07/01/0e6127f1ac11/","content":"\n# [CTSC1997] 选课\n\n## 题目描述\n\n在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？\n\n## 输入格式\n\n第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \\leq N \\leq 300$ , $1 \\leq M \\leq 300$ )\n\n接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \\leq {k_i} \\leq N$ , $1 \\leq {s_i} \\leq 20$）。\n\n## 输出格式\n\n只有一行，选 $M$ 门课程的最大得分。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7  4\n2  2\n0  1\n0  4\n2  1\n7  1\n7  6\n2  2\n```\n\n### 样例输出 #1\n\n```\n13\n```\n\n## 思路\n\n课和课之间的关系构成森林。但是加入0节点后则构成一棵树（没有先修课的课程先修课序号为0），可以将0看作一门0学分的课程，这样就把所有课程的关系变为了一棵树。\n\n本题节点与节点之间不仅有树形结构的依赖关系，还有重量-价值的关系，可以联想到背包。\n\n那么如何在树上进行背包？\n\n设 $f[now][j][k]$ 表示为以 $now$ 为根，前 $j$ 个节点选 $k$ 门课的价值。\n\n如果前1个节点选1门课，那么就是选根节点，因此有： $f[now][1][1] = val[now] $\n\n可以推出状态转移方程：\n\n $f[now][j][k]=max(f[now][j-1][k],f[son][son节点所有节点][l]+f[now][j-1][k-l])$\n\n右边两种状态解释：\n\n$f[now][j-1][k]$ ： 不选当前节点。\n\n$ f[son][son节点所有节点][l]+f[now][j-1][k-l]$ ：在son节点中选 $l$ 个节点，在父亲节点中少选 $l$ 个节点。\n\n由于我们要先处理 $now$ 结点的子树，因此 $f[son][son节点所有节点][l]$ 是已知量。\n\n在处理第 $j$ 个节点时，前 $j-1$ 个节点都是已经处理好了的，因此带有 $j-1$ 的量不用考虑循环顺序问题。\n\n$l$ 是子树中选择节点的数量，它的数量一定小于总节点数，因此 $l<k$ ，因此倒着循环 $k$ ，可以使数组当前值与已经用到的值不受影响。（类似一维背包压维）\n\n最后得出状态转移方程：\n\n$f[now][j]=max(f[now][j],f[son][l]+f[now][j-l])$ \n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint f[310][310],cnt,head[1010];\nstruct edge{\n\tint to,nxt;\n}e[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tdp(to);//从最深处的子节点开始向上逐一计算\n        //先计算子节点状态，用子节点状态推出父节点状态\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tfor(int j=m+1;j>=1;j--)//默认根节点为0且必取，相当于多一门课 类似一维背包压维\n\t\t{\n\t\t\tint to=e[i].to;//x的子节点\n            //f[x][j]代表以x为根的子树取j个节点的时候能取得的最大值\n            //第x门课和它之后的课的最大学分\n\t\t\tfor(int k=0;k<j;k++)//遍历重量\n\t\t\t{\n\t\t\t\tf[x][j]=max(f[x][j],f[to][k]+f[x][j-k]);\n                //f[to][k] x节点子树选了k门课\n                //f[x][j-k] 相应的，x就要少选k门课\n                //状态转移方程理解为：不选这个子树上的节点，或者选某些节点，同时少选其他节点（以取得最大值）\n                //由于子树先处理，因此f[to][k]是已经知道被处理出来的值\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint fa,v;\n\t\tcin>>fa>>v;\n\t\tf[i][1]=v;//初状态为只选这门课，那么值就等于该门课学分\n\t\tadd(fa,i);\n\t}\n\tdp(0);\n\tcout<<f[0][m+1];//以0为根选了m+1门课\n\treturn 0;\n } \n```","tags":["树形结构","树形dp","树形背包"],"categories":["题解"]},{"title":"P1122 最大子树和","url":"/2022/07/01/e8bfd67e2f67/","content":"# 最大子树和\n\n## 题目描述\n\n小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有$N $朵花，共有$N-1$条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。\n\n## 输入格式\n\n第一行一个整数$N(1 ≤ N ≤ 16000)$。表示原始的那株花卉上共$N $朵花。\n\n第二行有$N $个整数，第$I$个整数表示第$I$朵花的美丽指数。\n\n接下来$N-1$行每行两个整数$a,b$，表示存在一条连接第$a$ 朵花和第$b$朵花的枝条。\n\n## 输出格式\n\n一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过$2147483647$。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n-1 -1 -1 1 1 1 0\n1 4\n2 5\n3 6\n4 7\n5 7\n6 7\n```\n\n### 样例输出 #1\n\n```\n3\n```\n\n## 提示\n\n【数据规模与约定】\n\n对于$60\\%$的数据，有$N≤1000$；\n\n对于$100\\%$的数据，有$N≤16000$。\n\n## 思路\n\n树形dp的基本思路：对每一个节点可以选择或者不选，选的节点可以选节点子树上的节点，不选的节点=放弃该节点整棵子树。\n\n因此对选与不选都要进行判断，说不定不选会放弃更多节点。\n\n$f[i][1]=max(f[i][1]+f[son][1],f[i][1]+f[son][0])$\n\n$f[i][0]=0$\n\n```cpp\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=20010;\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nint n,cnt,head[N*2],val[N],f[N][2],ans=-1145141919;\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdp(1,0);\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,f[i][1]);//小细节，最后的值一定是选了某个结点的f\n        //一开始把0和1都带进去，遇见全负会一个都不选wa\n        //理解起来很简单，最后的答案一定至少有一个节点，那么必定是某个选了的节点的f向两边衍生的树\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"P3398 仓鼠找sugar","url":"/2022/06/30/1a08171575b0/","content":"\n# 仓鼠找 sugar\n\n## 题目描述\n\n小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？\n\n\n小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！\n\n## 输入格式\n\n第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。\n\n接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。\n\n接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。\n\n## 输出格式\n\n对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5\n2 5\n4 2\n1 3\n1 4\n5 1 5 1\n2 2 1 4\n4 1 3 4\n3 1 1 5\n3 5 1 4\n```\n\n### 样例输出 #1\n\n```\nY\nN\nY\nY\nY\n```\n\n## 提示\n\n本题时限1s，内存限制128M，因新评测机速度较为接近NOIP评测机速度，请注意常数问题带来的影响。\\_\\_\n\n\n20%的数据 n<=200,q<=200\n\n40%的数据 n<=2000,q<=2000\n\n70%的数据 n<=50000,q<=50000\n\n100%的数据 n<=100000,q<=100000\n\n## 思路\n画图+仔细思考可以发现规律：如果两条路径相交，那么一条路径端点的LCA必定在另一条路径上。那么如何证明一个点是否在一条路径上？想想数轴，如果一个点在某线段上，那么点到线段两端的距离=线段长度。在LCA中，可以采用差分来求出路径长度，即：\n\n$ dis(a,b)=abs(dep[LCA(a,b)]-dep[a])+abs(dep[LCA(a,b)]-dep[b])$\n\n用代码表示：\n\n```cpp\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\n\nint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){//如果lca到路径两端距离=路径\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint n,q,cnt,head[N*2],dep[N],fa[N][25];\nstruct edge{\n\tint to,next;\n}e[N*2];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t}\n\tfor(int i=head[now];i;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs(to,now);\n\t\t}\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n\t}\n\treturn 0;\n}\n```","tags":["树形结构","最近公共祖先","倍增"],"categories":["题解"]},{"title":"算法学习笔记（1）-倍增求LCA","url":"/2022/06/30/16dd215545c0/","content":"\n# 【模板】最近公共祖先（LCA）\n\n## 题目描述\n\n如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n\n## 输入格式\n\n第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n\n## 输出格式\n\n输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5 4\n3 1\n2 4\n5 1\n1 4\n2 4\n3 2\n3 5\n1 2\n4 5\n```\n\n### 样例输出 #1\n\n```\n4\n4\n1\n4\n4\n```\n\n## 提示\n\n对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n\n对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n\n对于 $100\\%$ 的数据，$N\\leq 500000$，$M\\leq 500000$。\n\n\n样例说明：\n\n该树结构如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n\n故输出依次为 $4, 4, 1, 4, 4$。\n\n## 朴素思路\n\n给定两个点 $a,b$ ，其深度分别是 $d1, d2(d1>d2)$ ，先令d1逐层向上跳跃，直到 $d1=d2$ ，之后 $d1,d2$ 一起向上跳跃，直到跳跃到同一个点，那个点就是最近公共祖先。（如果 $d1=d2$ 时点就是同一个点，那么该点就是其最近公共祖先。 通过复杂度分析不难发现该算法的时间复杂度为 $ O(n)$ ,面对$n $次询问的时间复杂度为 $O(n^2)$，面对超过5000的数据范围就无法承受。\n\n是否有其他更好做法？\n\n## 倍增\n\n任意一个数字都可以用二进制的形式被表达出，例如 $7=4+2+1$ ，在这里$7=2^2+2^1+2^0$，我们可以使 $d1$每次向上跳跃的层数都是2的幂，例如要想上跳7层，第一次跳 $2^2$ 层 ，第二次跳 $2^1$ 层，此三次跳 $2^0$ 层。这就是倍增的思想，显然对于 $n$ 层跳跃，倍增法仅需跳跃 $log n$ 次，可以大大简化时间复杂度。\n\n### 预处理\n\n我们先用简单的数列来看一下倍增到底是如何实现的。\n\n$1,2,3,4,5,6,7,8,9,10$\n\n令 $f[1][x]$ 来代表 $1$ 之后 $2^x$ 是什么数字，通过分析可以发现：\n\n$f[1][0]=2, f[1][1]=3, f[1][2]=5, f[1][3]=9$\n\n同理，$f[2][0]=3, f[2][1]=4, f[2][2]=8, f[2][3]=10$\n\n同时，我们不难发现，通过幂函数的性质 $2^n=2^{n-1} +2^{n-1} $，可以得出递推式：$f[i][j]=f[f[i][j-1]][j-1]$，即向右跨出 $j$ 个格子等效于先向右跨出 $j-1$ 个格子，再在这个格子向右跨 $j-1$ 个格子。\n\n例：$f[1][4]=16=f[f[1][3]][3]=f[8][3]$。\n\n\n那么，对于一棵树，我们也能通过这种方法来预处理出第 $i$ 个结点向上 $2^n$ 层的结点是。先预处理出表格，在倍增是直接套用即可。\n\n即: $f[i][j]$ 代表 $i $ 节点向上跳跃 $2^j$ 个父亲。\n\n用dfs预处理出以上我们要求的信息，形成一张表格：\n```cpp\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;//now结点的深度比父亲节点深度大1（往下一层）\n\tfa[now][0]=father;//now节点向上跳1层是父亲节点\n\tfor(int i=1;(1<<i)<=dep[now];i++)//他向上跳的层数肯定小于他自己的深度\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];//递推，理由在上面解释\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)//向它的儿子进行dfs，找出儿子的一堆父亲\n\t\t\tdfs(e[i].to,now);\n\t}\n}\n```\n### 求LCA\n\n那么如何求LCA呢？\n\n现在我们已经有了一张预处理的表格，那么我们目前就要用这张预处理的表格来找出他们的祖先。想法和朴素的思路类似：先将深度较大的点跳到和另一个点同一高度，然后两个点同时用倍增法向上跳。\n\n要注意的是，每次跳跃的高度都是向上跳 $2^{n_{max}}$ 层，即每次要尽可能向上跳大的距离。但是有一个限制条件：这两个点在同时向上跳的时候，不能跳到相遇的点。道理很简单，两个点在同一层，它们尽可能向上跳正好跳到相遇的点，但是不能保证这个点下面的点不能相遇，这样这个点就不是最近的公共祖先了。因此要加上一个限制条件：这两个点向上跳以后不是同一个点。而要跳到不能再向上跳（两个点再向上跳 ( $2^0=1$ ) 层就能相遇），那此时任意点的父亲就是它们的最近公共祖先。\n\n```cpp\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);//默认depx>depy\n\tfor(int i=20;i>=0;i--)//从最大幂次开始尽可能向上跳\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];//深度还大于y就接着往上跳\n\t\tif(x==y)return x;//在这一步就相遇说明y就是最近的公共祖先（此时y=x）\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])//如果向上跳到的不是同一个点\n\t\t{\n\t\t\tx=fa[x][i];//一起向上跳2^i层\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];//最近公共祖先就是x，y任意点的父亲\n}\n```\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint to,nxt;\n}e[500010<<1];\nint fa[500010][22],dep[500010],cnt,head[500010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\t//cout<<now<<\"k\"<<endl;\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t\t//cout<<fa[now][i]<<\" \"<<now<<\" \"<<i<<endl;\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)\n\t\t\tdfs(e[i].to,now);\n\t}\n}\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint main()\n{\n\t//memset(head,-1,sizeof(head));\n\tint n,m,s;\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tadd(a,b);\n\t\tadd(b,a); \n\t}\n\tdfs(s,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<LCA(a,b)<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n","tags":["树形结构","最近公共祖先","倍增"],"categories":["笔记"]},{"title":"P5536 【XR-3】核心城市","url":"/2022/06/28/4c28eade2351/","content":"# 【XR-3】核心城市\n\n## 题目描述\n\nX 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。\n\nX 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：\n\n1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。\n2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。\n\n## 输入格式\n\n第一行 $2$ 个正整数 $n,k$。\n\n接下来 $n - 1$ 行，每行 $2$ 个正整数 $u,v$，表示第 $u$ 座城市与第 $v$ 座城市之间有一条长度为 $1$ 的道路。\n\n**数据范围：**\n\n- $1 \\le k < n \\le 10 ^ 5$。\n- $1 \\le u,v \\le n, u \\ne v$，保证城市与道路形成一棵树。\n\n## 输出格式\n\n一行一个整数，表示答案。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n6 3\n1 2\n2 3\n2 4\n1 5\n5 6\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 提示\n\n【样例说明】\n\n钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。\n\n## 思路\n\n这道题的题目就有一点像在玩文字游戏的意思....\n\n简单来说：核心城市是一个团，其中每两个点都有链接。用yy能力把核心城市缩成一个点，要求的是所有点到核心城市点的最长距离的最小值。\n\n我们要做的是确定几个核心城市的位置，使得其他点到核心城市最长距离最小。\n\n先从简单的想起：假如就确定一个核心城市的位置，这个核心城市应该在哪？\n\n答案是整颗树直径的中点（可以理解为到每个最深结点的平均距离差值最小）。这时候到树上任意一点最大值最小。那么如果要令最大值最大，这个点应该在哪呢？\n\n答案是树的直径的端点。\n\n### 树的直径\n\n树的直径可以理解为树上最长的一条链。因此，接上文，如果在直径的端点，那么核心城市的距离就是树的直径（最长链），那最长距离必定最大。\n\n#### 如何求树的直径\n\n有两种方法：两次dfs（bfs）或者dp。dp方法不易求出树上的点，与我们要求出树的中心目的不符，在此仅介绍两次dfs做法。\n\n第一次dfs：任意选取一个点，开始dfs，搜索到最深处（树的直径的一个端点）\n\n第二次dfs：从树的端点开始dfs，dfs到最深处（树的另一个端点）\n\n这样求出来的就是最长链。在网上能搜到详细证明，在这里就不赘述，知道就行了。\n\n由于树的直径的中点必定在直径上（废话），因此可以在dfs的时候标记处整条直径，然后在直径上找出中点。\n\n两次dfs：\n```cpp\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)//mxdp是设置的目前最大深度，因为要找到最深的端点\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)//直径，和mxdp其实可以用同一个变量。\n\t{\n\t\tzj=dep;\n\t\ttag=x;//标记出另一个端点的编号\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;//标记出每个点的父亲。方便之后沿着链来寻找中点\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\n```\n为什么标记了父亲就能寻找到中点？因为我们通过第二次dfs可以找到另一个端点的编号，而在标记处该编号的父亲便可以通过寻找父亲一直寻找到直径的另一头。\n\n哪个是中点？直径长度一半就是中点。如果带有小数点 $0.5$ ，那说明有两个中点，无论哪个都可以。\n```cpp\nint mid=tag;//tag就是找出的另一个端点\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];//找直径/2次自己的父亲就是中点\n```\n解决了中点的问题，我们想起来：核心城市并不是一个点，它是很多个点构成的点集。那么对于除了直径中点以外的点怎么处理呢？\n\n贪心！\n\n每个点到这个点可以到达的最深点都有一个距离。而这个距离就是可能的最长链的长度。该距离 $d = maxdeep[x]-deep[x]$ ，即是该点可到达最深深度-自己的深度。如果将其从大到小排序，如果有k个核心城市，那么前k个就是第k长的最长链，是要去掉的。而 $d[k+1]+1$ 是我们所要求的最长链的最小值。\n\n例：假设 $k=3$\n\n从核心城市到它能到达的最深点（应该是直径一端）的距离为 $d[1]$ 。\n\n第二个城市 $d[2]$ 。\n\n第三个城市 $d[3]$。\n\n那么第四个城市（除了核心城市以外的第一座城市，即除了核心城市以外自身到最深点的最长链）$=d[4]$\n\n为什么还要 $+1$ ？\n\n因为我们求的 $d$ 是该点本身到该点能到达的最深深度的距离，他还要连接到核心城市上，这里是 $1$ 的距离，因此最后答案要 $+1 $。\n\n代码中用了四次dfs：\n\n第一次求出直径的一端\n\n第二次求出直径的另一端\n\n找出中点\n\n第三次以中点为树根标记各个节点深度\n\n第四次寻找每个深度的 $d$\n\n中间其实可以省略一次dfs，但是我觉得四次dfs也挺清晰的。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct edge{\n\tint to,nxt;\n}e[200010];\nint head[200010],cnt,dept[100010],mxdp,tag,mid;\nint dis[100010],fa[100010],zj,maxdeep[100010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nbool cmp(int a,int b){\n\treturn a>b;\n}\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)\n\t{\n\t\tzj=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs3(int x,int father,int dep)\n{\n\tdept[x]=dep;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs3(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs4(int x,int father)\n{\n\tmaxdeep[x]=dept[x];\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs4(to,x);\n\t\t\tmaxdeep[x]=max(maxdeep[x],maxdeep[to]);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdfs1(1,0,0);\n\tdfs2(tag,0,0);\n\tint mid=tag;\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];\n\tdfs3(mid,0,0);\n\tdfs4(mid,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmaxdeep[i]-=dept[i];\n\t}\n\tsort(maxdeep+1,maxdeep+n+1,cmp);\n\tcout<<maxdeep[k+1]+1;\n\treturn 0;\n}\n```","tags":["树形结构","树的直径","贪心"],"categories":["题解"]},{"title":"P5018 [NOIP2018 普及组] 对称二叉树","url":"/2022/06/28/4d1511918017/","content":"\n# [NOIP2018 普及组] 对称二叉树\n\n## 题目描述\n\n一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： \n\n1.  二叉树； \n2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   \n\n下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  \n\n![](https://cdn.luogu.com.cn/upload/pic/43192.png)   \n\n现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。   \n\n注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。\n\n## 输入格式\n\n第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \\sim n$，其中节点 $1$ 是树根。 \n\n第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。 \n\n接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。\n\n## 输出格式\n\n输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2 \n1 3 \n2 -1 \n-1 -1\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n10 \n2 2 5 5 5 5 4 4 2 3 \n9 10 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 2 \n3 4 \n5 6 \n-1 -1 \n7 8\n```\n\n### 样例输出 #2\n\n```\n3\n```\n\n## 提示\n\n【输入输出样例 1 说明】  \n![](https://cdn.luogu.com.cn/upload/pic/43188.png)     \n最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   \n\n【输入输出样例 2 说明】   \n![](https://cdn.luogu.com.cn/upload/pic/43189.png)     \n最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 \n\n【数据规模与约定】    \n共 $25$ 个测试点。    \n$v_i ≤ 1000$。   \n测试点 $1 \\sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。   \n测试点 $4 \\sim 8, n ≤ 10$。  \n测试点 $9 \\sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。   \n测试点 $13 \\sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。  \n测试点 $17 \\sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。  \n测试点 $21 \\sim 25, n ≤ 10^6$。 \n \n本题约定： \n\n层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 \n \n 树的深度：树中节点的最大层次称为树的深度。 \n \n 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43190.png)  \n完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43191.png)\n\n\n ## 思路\n\n 树形结构的暴力，有助于提升对树的认知\n\n 目标：\n\n 1.判断二叉树结构是否对称\n\n 2.判断二叉树权值是否对称\n\n 3.判断二叉树的大小\n\n 把每个节点视作树的根，将其视作一棵二叉树，判断其结构、权值是否对称，计算其大小。通过递归可以得出。\n\n 判断二叉树对称：\n\n ```cpp\n bool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n ```\n ### 判断对称的条件：\n\n 1.左右都没有子树（都是-1），那么二叉树对称（只有自己节点，当然对称）\n\n 2.左右子树对称（结构对称且权值对称 $val[x]==val[y]$ ）。判断左右子树是否对称，可以采用1（该子树没有左右子树），或者2（该子树的左右子树对称），可以直接递归解决，即: $check(ls[x],rs[y])==1 且 check(ls[y],rs[x])==1 $ 。\n 令 $x$ 为该树左节点，$y$ 为该书右结点，则 $ls[x],rs[y]$ 代表其左节点的左子树和右节点的右子树，根据图片可以发现他们是满足对称的条件。另一个等式也是同样的道理\n\n 判断不对称：\n\n 1.只有一个子树存在\n\n 2.权值不等\n\n 3.左右子树不等\n\n ---------------------\n ### 判断树的子节点数\n\n 如果有左子树，加上左子树的节点数。对右子树同理。最后加上根节点（自己）\n\n```cpp\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\n```\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nint rs[1000100],ls[1000100],val[1000100],cnts[1000100];\nbool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>ls[i]>>rs[i];\n\tcnt(1);//默认1是根节点，从1号点开始找\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(check(ls[i],rs[i]))//经检查该树对称\n\t\t{\n\t\t\tans=max(ans,cnts[i]);//答案=目前最大值或者该树的节点数\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","递归"],"categories":["题解"]},{"title":"P1364 树的重心","url":"/2022/06/28/1b3206c4f64a/","content":"\n# 医院设置\n\n## 题目描述\n\n设有一棵二叉树，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/166.png)\n\n其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在1 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。\n\n## 输入格式\n\n第一行一个整数 $n$，表示树的结点数。\n\n接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。\n\n## 输出格式\n\n一个整数，表示最小距离和。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\t\t\t\t\t\t\n13 2 3\n4 0 0\n12 4 5\n20 0 0\n40 0 0\n```\n\n### 样例输出 #1\n\n```\n81\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。\n\n## 思路\n\n思路1：数据范围  $1 \\leq n \\leq 100$ ，可以考虑Floyd求最短路，求出任意两个点间最短距离，然后从1到N穷举医院的位置，找出最小值。\n\n思路2：加入数据更大呢？如果 $1 \\leq n \\leq 10000$ ，Floyd+穷举的方法肯定行不通。引出概念：树的重心。\n\n什么是树的重心？\n### 1.树的重心的定义：\n\n树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。\n\n### 2.树的重心的性质：\n\n1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。\n\n2、插入或删除一个点，树的重心的位置最多移动一个单位。\n\n3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。\n\n本题中只需要用到第一条性质，求出所有点（权）到树的重心的距离的最小值。\n\n### 3.如何求树的重心：\n\n动态规划求树的重心：定义 $f[i]$ 为以 $i$ 为根（医院）的总距离，$size[i]$ 为以 $i$为根的子树的总大小。\n\n那么有：$f[j] = f[i]+size[1]-2*size[j]$\n\n为什么？\n\n当根从 $i$ 变为 $j$ 时，根的子树到根的距离原先到 $i$ ，现在到 $j$ ，所有子树到根的距离都减小了1，而当前子树大小为 $size[j]$ ，因此减少的总距离为 $size[j]$ 。但是，除了子树之外的部分原先只要到 $i$ ，现在要到 $j$ 了，距离增加了1，因此增加的总距离为 $size[1]-size[j]$ 。于是可以得到：$f[j] = f[i]+size[1]-2*size[j]$ 。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[1010];\nint head[1010],n,pop[1010],cnt;\nint size[1010],ans=114514,f[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int x,int father,int dep)\n{\n\tsize[x]=pop[x];//因为本题中每个点有点权（人口），因此点权要计入树的大小。\n\tfor(int i=head[x];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tdfs(e[i].to,x,dep+1);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t}\n\t}\n\tf[1]+=(pop[x]*dep);//f[1]代表到f[1]的总距离，之后从f[1]开始向后进行dp\n}\nvoid dp(int u,int father)\n{\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tf[e[i].to]=f[u]+size[1]-2*size[e[i].to];\n\t\t\tdp(e[i].to,u);\n\t\t}\n\t\tans=min(f[u],ans);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pop[i];\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tif(u)add(i,u);\n\t\tif(v)add(i,v);\n\t}\n\tdfs(1,0,0);\n\tdp(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n```\n","tags":["树形结构","树的重心","最短路"],"categories":["题解"]},{"title":"P1352 没有上司的舞会","url":"/2022/06/28/b1aaafc3fcd9/","content":"# 没有上司的舞会\n## 题目描述\n\n某大学有 $ n $ 个职员，编号为 $1\\ldots n$。 \n\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n\n## 输入格式\n\n输入的第一行是一个整数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n\n第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n\n\n## 输出格式\n\n输出一行一个整数代表最大的快乐指数。\n\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n1\n1\n1\n1\n1\n1\n1\n1 3\n2 3\n6 4\n7 4\n4 5\n3 5\n```\n\n### 样例输出 #1\n\n```\n5\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq l, k \\leq n$，且给出的关系一定是一棵树。\n\n## 思路\n\n对于每一个人，有两种状态：来参加聚会或者不来参加聚会。能否使用 $f[i]$ 来表示这个人的位置能获得的最大幸福指数？不行。因为他是否去参加聚会对他之后的人是会产生影响的，即这个问题里是有后效性的。无后效性是dp里的一个重要问题，如果 $f[i]$ 就能获得该位置的最大幸福度，根据动态规划的无后效性定义：在 $f[i]$ 之后的 $f[i+1] \\ldots f[i+n]$ 与 $f[i]$ 是没有关系的，但是这道题中是否选择 $i$ 会对之后的状态产生影响，与无后效性矛盾，因此不能用 $f[i]$ 表示状态来进行动态规划。\n\n那么怎么用动态规划来解决这道问题呢？\n\n由于后效性实际上是对之后状态的不清楚。即：如果使用 $f[i]$ 表示状态，我们无法确定的表示出状态（取还是不取都会影响）。因此尝试加一维：即用 $f[i][0]$ 和 $f[i][1]$ 来表示两种状态：在 $i$ 时取这个人和不取这个人，然后分别根据两种状态来进行dp，似乎就可以做下去了。\n\n当不取第 $i$ 个人时候，$f[i][0]$ 在最初等于 $ 0 $ （因为不取他自己也就不加上他自身的快乐值 $r_i$），然后在 $f[i][0]=0$ 的基础上进行累加，找出它的最大值，即 $f[i][0] = max(f[son][1],f[son][0])$ 。即这个状态等于 $0 + 它下属能取到的最大快乐值 $ 。同理，当取第 $i$ 个人的时候，$f[i][1]=r_i$ 。（取了自身，加上自己的快乐值 $r_i$ ），状态转移方程为 $f[i][1] = r_i + max(f[son][0],f[son][1])$ 。\n\n因此，对于每个人的两种状态都进行一次状态转移，因为是从根部往下进行转移，因此动态规划的起点在这棵树的根部。\n\n先找出根部：由于每两个人之间都有记录上司的关系，因此在输入的时候为下属定义一个 $bool$ 型数组，记录它是否有上司，最后记录到没有上司的那个点就是树的根部（大领导）。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> son[10010]; \nint f[10010][2],r[10010],v[10010];\nvoid dp(int x)\n{\n\tf[x][0]=0;\n\tf[x][1]=r[x];\n\tfor(int i=0;i<son[x].size();i++)\n\t{\n\t\tint nxt=son[x][i];\n\t\tdp(nxt);\n\t\tf[x][0]+=max(f[nxt][0],f[nxt][1]);\n\t\tf[x][1]+=f[nxt][0];\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>r[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint l,k;\n\t\tcin>>l>>k;\n\t\tson[k].push_back(l);\n\t\tv[l]=1; //记录是否有上司\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!v[i])rt=i;\n\tdp(rt);\n\tcout<<max(f[rt][0],f[rt][1]);\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"Hello World","url":"/2022/06/27/1fc55095b3bb/","content":"第一篇md博客试试水\n\n不会网站又404了吧\n\n好像没有404 找到之前一直404的原因了 大成功\n\n今天再调一调主题什么的乱七八糟的\n\n\n从下午两点开始整 整到下午六点 当时以为忽略每次推送CNAME消失而导致网页404直接把整个项目删除了又重新建了一个 解决了不知道多少奇奇怪怪的问题 终于感觉差不多搞好了\n\n目前用git推到github上的时候貌似还会经常出现网络问题(errno 10053和无法连接到github） 希望也能尽快解决吧\n\n----------\n\n2022/06/28 00：01\n\n之前本地预览hexo s可以正常浏览网页，但是部署之后一点除了主页之外的任何网页就寄，终于修好了，呜呜呜\n\n有点困，再修一会睡觉。7.4就要小学期学汇编语言了，怎么到今天都没人陪我玩游戏。\n\n\n----------\n\n2022/06/28 00:33\n\n把分类、标签、关于页面也弄出来了，大成功(bushi\n\n开森\n\n基础的网站算是搭好了\n\n------------\n\n2022/06/28 11:39\n\n解决了markdown不显示数学公式的问题\n\n------------------------\n\n2022/06/28 16:39\n\n更换了Mist主题，搭配canvas_nest感觉超级好看\n\n添加了搜索功能\n\n把代码块的样式美化成了Mac的样式\n\n添加了头像\n\n（这5个小时的工作内容）\n\n感觉美化工作也工作的差不多了！\n\n","tags":["碎碎念"],"categories":["随笔"]}]