[{"title":"P1364 树的重心","url":"/2022/06/28/1b3206c4f64a/","content":"\n# 医院设置\n\n## 题目描述\n\n设有一棵二叉树，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/166.png)\n\n其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在1 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。\n\n## 输入格式\n\n第一行一个整数 $n$，表示树的结点数。\n\n接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。\n\n## 输出格式\n\n一个整数，表示最小距离和。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\t\t\t\t\t\t\n13 2 3\n4 0 0\n12 4 5\n20 0 0\n40 0 0\n```\n\n### 样例输出 #1\n\n```\n81\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。\n\n## 思路\n\n思路1：数据范围  $1 \\leq n \\leq 100$ ，可以考虑Floyd求最短路，求出任意两个点间最短距离，然后从1到N穷举医院的位置，找出最小值。\n\n思路2：加入数据更大呢？如果 $1 \\leq n \\leq 10000$ ，Floyd+穷举的方法肯定行不通。引出概念：树的重心。\n\n什么是树的重心？\n### 1.树的重心的定义：\n\n树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。\n\n### 2.树的重心的性质：\n\n1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。\n\n2、插入或删除一个点，树的重心的位置最多移动一个单位。\n\n3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。\n\n本题中只需要用到第一条性质，求出所有点（权）到树的重心的距离的最小值。\n\n### 3.如何求树的重心：\n\n动态规划求树的重心：定义 $f[i]$ 为以 $i$ 为根（医院）的总距离，$size[i]$ 为以 $i$为根的子树的总大小。\n\n那么有：$f[j] = f[i]+size[1]-2*size[j]$\n\n为什么？\n\n当根从 $i$ 变为 $j$ 时，根的子树到根的距离原先到 $i$ ，现在到 $j$ ，所有子树到根的距离都减小了1，而当前子树大小为 $size[j]$ ，因此减少的总距离为 $size[j]$ 。但是，除了子树之外的部分原先只要到 $i$ ，现在要到 $j$ 了，距离增加了1，因此增加的总距离为 $size[1]-size[j]$ 。于是可以得到：$f[j] = f[i]+size[1]-2*size[j]$ 。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[1010];\nint head[1010],n,pop[1010],cnt;\nint size[1010],ans=114514,f[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int x,int father,int dep)\n{\n\tsize[x]=pop[x];//因为本题中每个点有点权（人口），因此点权要计入树的大小。\n\tfor(int i=head[x];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tdfs(e[i].to,x,dep+1);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t}\n\t}\n\tf[1]+=(pop[x]*dep);//f[1]代表到f[1]的总距离，之后从f[1]开始向后进行dp\n}\nvoid dp(int u,int father)\n{\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tf[e[i].to]=f[u]+size[1]-2*size[e[i].to];\n\t\t\tdp(e[i].to,u);\n\t\t}\n\t\tans=min(f[u],ans);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pop[i];\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tif(u)add(i,u);\n\t\tif(v)add(i,v);\n\t}\n\tdfs(1,0,0);\n\tdp(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n```\n","tags":["树形结构","树的重心","最短路"],"categories":["题解"]},{"title":"P1352 没有上司的舞会","url":"/2022/06/28/b1aaafc3fcd9/","content":"# 没有上司的舞会\n## 题目描述\n\n某大学有 $ n $ 个职员，编号为 $1\\ldots n$。 \n\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n\n## 输入格式\n\n输入的第一行是一个整数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n\n第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n\n\n## 输出格式\n\n输出一行一个整数代表最大的快乐指数。\n\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n1\n1\n1\n1\n1\n1\n1\n1 3\n2 3\n6 4\n7 4\n4 5\n3 5\n```\n\n### 样例输出 #1\n\n```\n5\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq l, k \\leq n$，且给出的关系一定是一棵树。\n\n## 思路\n\n对于每一个人，有两种状态：来参加聚会或者不来参加聚会。能否使用 $f[i]$ 来表示这个人的位置能获得的最大幸福指数？不行。因为他是否去参加聚会对他之后的人是会产生影响的，即这个问题里是有后效性的。无后效性是dp里的一个重要问题，如果 $f[i]$ 就能获得该位置的最大幸福度，根据动态规划的无后效性定义：在 $f[i]$ 之后的 $f[i+1] \\ldots f[i+n]$ 与 $f[i]$ 是没有关系的，但是这道题中是否选择 $i$ 会对之后的状态产生影响，与无后效性矛盾，因此不能用 $f[i]$ 表示状态来进行动态规划。\n\n那么怎么用动态规划来解决这道问题呢？\n\n由于后效性实际上是对之后状态的不清楚。即：如果使用 $f[i]$ 表示状态，我们无法确定的表示出状态（取还是不取都会影响）。因此尝试加一维：即用 $f[i][0]$ 和 $f[i][1]$ 来表示两种状态：在 $i$ 时取这个人和不取这个人，然后分别根据两种状态来进行dp，似乎就可以做下去了。\n\n当不取第 $i$ 个人时候，$f[i][0]$ 在最初等于 $ 0 $ （因为不取他自己也就不加上他自身的快乐值 $r_i$），然后在 $f[i][0]=0$ 的基础上进行累加，找出它的最大值，即 $f[i][0] = max(f[son][1],f[son][0])$ 。即这个状态等于 $0 + 它下属能取到的最大快乐值 $ 。同理，当取第 $i$ 个人的时候，$f[i][1]=r_i$ 。（取了自身，加上自己的快乐值 $r_i$ ），状态转移方程为 $f[i][1] = r_i + max(f[son][0],f[son][1])$ 。\n\n因此，对于每个人的两种状态都进行一次状态转移，因为是从根部往下进行转移，因此动态规划的起点在这棵树的根部。\n\n先找出根部：由于每两个人之间都有记录上司的关系，因此在输入的时候为下属定义一个 $bool$ 型数组，记录它是否有上司，最后记录到没有上司的那个点就是树的根部（大领导）。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> son[10010]; \nint f[10010][2],r[10010],v[10010];\nvoid dp(int x)\n{\n\tf[x][0]=0;\n\tf[x][1]=r[x];\n\tfor(int i=0;i<son[x].size();i++)\n\t{\n\t\tint nxt=son[x][i];\n\t\tdp(nxt);\n\t\tf[x][0]+=max(f[nxt][0],f[nxt][1]);\n\t\tf[x][1]+=f[nxt][0];\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>r[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint l,k;\n\t\tcin>>l>>k;\n\t\tson[k].push_back(l);\n\t\tv[l]=1; //记录是否有上司\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!v[i])rt=i;\n\tdp(rt);\n\tcout<<max(f[rt][0],f[rt][1]);\n\treturn 0;\n}\n```","tags":["树形dp","树形结构"],"categories":["题解"]},{"title":"Hello World","url":"/2022/06/27/1fc55095b3bb/","content":"第一篇md博客试试水\n\n不会网站又404了吧\n\n好像没有404 找到之前一直404的原因了 大成功\n\n今天再调一调主题什么的乱七八糟的\n\n\n从下午两点开始整 整到下午六点 当时以为忽略每次推送CNAME消失而导致网页404直接把整个项目删除了又重新建了一个 解决了不知道多少奇奇怪怪的问题 终于感觉差不多搞好了\n\n目前用git推到github上的时候貌似还会经常出现网络问题(errno 10053和无法连接到github） 希望也能尽快解决吧\n\n----------\n\n2022/06/28 00：01\n\n之前本地预览hexo s可以正常浏览网页，但是部署之后一点除了主页之外的任何网页就寄，终于修好了，呜呜呜\n\n有点困，再修一会睡觉。7.4就要小学期学汇编语言了，怎么到今天都没人陪我玩游戏。\n\n\n----------\n\n2022/06/28 00:33\n\n把分类、标签、关于页面也弄出来了，大成功(bushi\n\n开森\n\n基础的网站算是搭好了\n\n------------\n\n2022/06/28 11:39\n解决了markdown不显示数学公式的问题","tags":["碎碎念"],"categories":["随笔"]}]