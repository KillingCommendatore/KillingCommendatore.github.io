[{"title":"P2014 [CTSC1997] 选课","url":"/2022/07/01/0e6127f1ac11/","content":"\n# [CTSC1997] 选课\n\n## 题目描述\n\n在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？\n\n## 输入格式\n\n第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \\leq N \\leq 300$ , $1 \\leq M \\leq 300$ )\n\n接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \\leq {k_i} \\leq N$ , $1 \\leq {s_i} \\leq 20$）。\n\n## 输出格式\n\n只有一行，选 $M$ 门课程的最大得分。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7  4\n2  2\n0  1\n0  4\n2  1\n7  1\n7  6\n2  2\n```\n\n### 样例输出 #1\n\n```\n13\n```\n\n## 思路\n\n课和课之间的关系构成森林。但是加入0节点后则构成一棵树（没有先修课的课程先修课序号为0），可以将0看作一门0学分的课程，这样就把所有课程的关系变为了一棵树。\n\n本题节点与节点之间不仅有树形结构的依赖关系，还有重量-价值的关系，可以联想到背包。\n\n那么如何在树上进行背包？\n\n设 $f[now][j][k]$ 表示为以 $now$ 为根，前 $j$ 个节点选 $k$ 门课的价值。\n\n如果前1个节点选1门课，那么就是选根节点，因此有： $f[now][1][1] = val[now] $\n\n可以推出状态转移方程： $f[now][j][k]=max(f[now][j-1][k],f[son][son节点所有节点][l]+f[now][j-1][k-l])$\n\n右边两种状态解释：\n\n$f[now][j-1][k]$ ： 不选当前节点。\n\n$ f[son][son节点所有节点][l]+f[now][j-1][k-l]$ ：在son节点中选 $l$ 个节点，在父亲节点中少选 $l$ 个节点。\n\n由于我们要先处理 $now$ 结点的子树，因此 $f[son][son节点所有节点][l]$ 是已知量。\n\n在处理第 $j$ 个节点时，前 $j-1$ 个节点都是已经处理好了的，因此带有 $j-1$ 的量不用考虑循环顺序问题。\n\n$l$ 是子树中选择节点的数量，它的数量一定小于总节点数，因此 $l<k$ ，因此倒着循环 $k$ ，可以使数组当前值与已经用到的值不受影响。（类似一维背包压维）\n\n最后得出状态转移方程：\n\n$f[now][j]=max(f[now][j],f[son][l]+f[now][j-l])$ \n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint f[310][310],cnt,head[1010];\nstruct edge{\n\tint to,nxt;\n}e[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tdp(to);//从最深处的子节点开始向上逐一计算\n        //先计算子节点状态，用子节点状态推出父节点状态\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tfor(int j=m+1;j>=1;j--)//默认根节点为0且必取，相当于多一门课 类似一维背包压维\n\t\t{\n\t\t\tint to=e[i].to;//x的子节点\n            //f[x][j]代表以x为根的子树取j个节点的时候能取得的最大值\n            //第x门课和它之后的课的最大学分\n\t\t\tfor(int k=0;k<j;k++)//遍历重量\n\t\t\t{\n\t\t\t\tf[x][j]=max(f[x][j],f[to][k]+f[x][j-k]);\n                //f[to][k] x节点子树选了k门课\n                //f[x][j-k] 相应的，x就要少选k门课\n                //状态转移方程理解为：不选这个子树上的节点，或者选某些节点，同时少选其他节点（以取得最大值）\n                //由于子树先处理，因此f[to][k]是已经知道被处理出来的值\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint fa,v;\n\t\tcin>>fa>>v;\n\t\tf[i][1]=v;//初状态为只选这门课，那么值就等于该门课学分\n\t\tadd(fa,i);\n\t}\n\tdp(0);\n\tcout<<f[0][m+1];//以0为根选了m+1门课\n\treturn 0;\n } \n```","tags":["树形结构","树形dp","背包"],"categories":["题解"]},{"title":"P1122 最大子树和","url":"/2022/07/01/e8bfd67e2f67/","content":"# 最大子树和\n\n## 题目描述\n\n小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有$N $朵花，共有$N-1$条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。\n\n## 输入格式\n\n第一行一个整数$N(1 ≤ N ≤ 16000)$。表示原始的那株花卉上共$N $朵花。\n\n第二行有$N $个整数，第$I$个整数表示第$I$朵花的美丽指数。\n\n接下来$N-1$行每行两个整数$a,b$，表示存在一条连接第$a$ 朵花和第$b$朵花的枝条。\n\n## 输出格式\n\n一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过$2147483647$。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n-1 -1 -1 1 1 1 0\n1 4\n2 5\n3 6\n4 7\n5 7\n6 7\n```\n\n### 样例输出 #1\n\n```\n3\n```\n\n## 提示\n\n【数据规模与约定】\n\n对于$60\\%$的数据，有$N≤1000$；\n\n对于$100\\%$的数据，有$N≤16000$。\n\n## 思路\n\n树形dp的基本思路：对每一个节点可以选择或者不选，选的节点可以选节点子树上的节点，不选的节点=放弃该节点整棵子树。\n\n因此对选与不选都要进行判断，说不定不选会放弃更多节点。\n\n$f[i][1]=max(f[i][1]+f[son][1],f[i][1]+f[son][0])$\n\n$f[i][0]=0$\n\n```cpp\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=20010;\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nint n,cnt,head[N*2],val[N],f[N][2],ans=-1145141919;\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dp(int now,int father)\n{\n\tf[now][0]=0;//不选这个节点，那么初始化为0\n\tf[now][1]=val[now];//选这个节点，初始化为这个结点的权值\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdp(to,now);//先算出下面结点的f，直到最后一个节点\n\t\t\tf[now][1]=max(f[now][1],f[now][1]+f[to][1]);//递归后一个个向上计算最大的值\n            //f[now][0]因为同时舍弃了子树因此不用计算\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdp(1,0);\n\tfor(int i=1;i<=n;i++)\n\t\tans=max(ans,f[i][1]);//小细节，最后的值一定是选了某个结点的f\n        //一开始把0和1都带进去，遇见全负会一个都不选wa\n        //理解起来很简单，最后的答案一定至少有一个节点，那么必定是某个选了的节点的f向两边衍生的树\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"P3398 仓鼠找sugar","url":"/2022/06/30/1a08171575b0/","content":"\n# 仓鼠找 sugar\n\n## 题目描述\n\n小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为1~n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（a）到餐厅（b），而他的基友同时要从他的卧室（c）到图书馆（d）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？\n\n\n小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！\n\n## 输入格式\n\n第一行两个正整数n和q，表示这棵树节点的个数和询问的个数。\n\n接下来n-1行，每行两个正整数u和v，表示节点u到节点v之间有一条边。\n\n接下来q行，每行四个正整数a、b、c和d，表示节点编号，也就是一次询问，其意义如上。\n\n## 输出格式\n\n对于每个询问，如果有公共点，输出大写字母“Y”；否则输出“N”。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5\n2 5\n4 2\n1 3\n1 4\n5 1 5 1\n2 2 1 4\n4 1 3 4\n3 1 1 5\n3 5 1 4\n```\n\n### 样例输出 #1\n\n```\nY\nN\nY\nY\nY\n```\n\n## 提示\n\n本题时限1s，内存限制128M，因新评测机速度较为接近NOIP评测机速度，请注意常数问题带来的影响。\\_\\_\n\n\n20%的数据 n<=200,q<=200\n\n40%的数据 n<=2000,q<=2000\n\n70%的数据 n<=50000,q<=50000\n\n100%的数据 n<=100000,q<=100000\n\n## 思路\n画图+仔细思考可以发现规律：如果两条路径相交，那么一条路径端点的LCA必定在另一条路径上。那么如何证明一个点是否在一条路径上？想想数轴，如果一个点在某线段上，那么点到线段两端的距离=线段长度。在LCA中，可以采用差分来求出路径长度，即：\n\n$ dis(a,b)=abs(dep[LCA(a,b)]-dep[a])+abs(dep[LCA(a,b)]-dep[b])$\n\n用代码表示：\n\n```cpp\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\n\nint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){//如果lca到路径两端距离=路径\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n```\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint n,q,cnt,head[N*2],dep[N],fa[N][25];\nstruct edge{\n\tint to,next;\n}e[N*2];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t}\n\tfor(int i=head[now];i;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs(to,now);\n\t\t}\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint dis(int a,int b)\n{\n\tint c=lca(a,b);\n\treturn abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tint e=lca(a,b),f=lca(c,d);\n\t\tint disab=dis(a,b),discd=dis(c,d);\n\t\tif(dis(a,f)+dis(b,f)==disab || dis(c,e)+dis(d,e)==discd){\n\t\t\tcout<<\"Y\\n\";\n\t\t}else cout<<\"N\\n\";\n\t}\n\treturn 0;\n}\n```","tags":["树形结构","最近公共祖先","倍增"],"categories":["题解"]},{"title":"倍增求LCA","url":"/2022/06/30/fb7a6c8505c1/","content":"\n# 【模板】最近公共祖先（LCA）\n\n## 题目描述\n\n如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n\n## 输入格式\n\n第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n\n## 输出格式\n\n输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 5 4\n3 1\n2 4\n5 1\n1 4\n2 4\n3 2\n3 5\n1 2\n4 5\n```\n\n### 样例输出 #1\n\n```\n4\n4\n1\n4\n4\n```\n\n## 提示\n\n对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n\n对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n\n对于 $100\\%$ 的数据，$N\\leq 500000$，$M\\leq 500000$。\n\n\n样例说明：\n\n该树结构如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n\n故输出依次为 $4, 4, 1, 4, 4$。\n\n## 朴素思路\n\n给定两个点 $a,b$ ，其深度分别是 $d1, d2(d1>d2)$ ，先令d1逐层向上跳跃，直到 $d1=d2$ ，之后 $d1,d2$ 一起向上跳跃，直到跳跃到同一个点，那个点就是最近公共祖先。（如果 $d1=d2$ 时点就是同一个点，那么该点就是其最近公共祖先。 通过复杂度分析不难发现该算法的时间复杂度为 $ O(n)$ ,面对$n $次询问的时间复杂度为 $O(n^2)$，面对超过5000的数据范围就无法承受。\n\n是否有其他更好做法？\n\n## 倍增\n\n任意一个数字都可以用二进制的形式被表达出，例如 $7=4+2+1$ ，在这里$7=2^2+2^1+2^0$，我们可以使 $d1$每次向上跳跃的层数都是2的幂，例如要想上跳7层，第一次跳 $2^2$ 层 ，第二次跳 $2^1$ 层，此三次跳 $2^0$ 层。这就是倍增的思想，显然对于 $n$ 层跳跃，倍增法仅需跳跃 $log n$ 次，可以大大简化时间复杂度。\n\n### 预处理\n\n我们先用简单的数列来看一下倍增到底是如何实现的。\n\n$1,2,3,4,5,6,7,8,9,10$\n\n令 $f[1][x]$ 来代表 $1$ 之后 $2^x$ 是什么数字，通过分析可以发现：\n\n$f[1][0]=2, f[1][1]=3, f[1][2]=5, f[1][3]=9$\n\n同理，$f[2][0]=3, f[2][1]=4, f[2][2]=8, f[2][3]=10$\n\n同时，我们不难发现，通过幂函数的性质 $2^n=2^{n-1} +2^{n-1} $，可以得出递推式：$f[i][j]=f[f[i][j-1]][j-1]$，即向右跨出 $j$ 个格子等效于先向右跨出 $j-1$ 个格子，再在这个格子向右跨 $j-1$ 个格子。\n\n例：$f[1][4]=16=f[f[1][3]][3]=f[8][3]$。\n\n\n那么，对于一棵树，我们也能通过这种方法来预处理出第 $i$ 个结点向上 $2^n$ 层的结点是。先预处理出表格，在倍增是直接套用即可。\n\n即: $f[i][j]$ 代表 $i $ 节点向上跳跃 $2^j$ 个父亲。\n\n用dfs预处理出以上我们要求的信息，形成一张表格：\n```cpp\nvoid dfs(int now,int father)\n{\n\tdep[now]=dep[father]+1;//now结点的深度比父亲节点深度大1（往下一层）\n\tfa[now][0]=father;//now节点向上跳1层是父亲节点\n\tfor(int i=1;(1<<i)<=dep[now];i++)//他向上跳的层数肯定小于他自己的深度\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];//递推，理由在上面解释\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)//向它的儿子进行dfs，找出儿子的一堆父亲\n\t\t\tdfs(e[i].to,now);\n\t}\n}\n```\n### 求LCA\n\n那么如何求LCA呢？\n\n现在我们已经有了一张预处理的表格，那么我们目前就要用这张预处理的表格来找出他们的祖先。想法和朴素的思路类似：先将深度较大的点跳到和另一个点同一高度，然后两个点同时用倍增法向上跳。\n\n要注意的是，每次跳跃的高度都是向上跳 $2^{n_{max}}$ 层，即每次要尽可能向上跳大的距离。但是有一个限制条件：这两个点在同时向上跳的时候，不能跳到相遇的点。道理很简单，两个点在同一层，它们尽可能向上跳正好跳到相遇的点，但是不能保证这个点下面的点不能相遇，这样这个点就不是最近的公共祖先了。因此要加上一个限制条件：这两个点向上跳以后不是同一个点。而要跳到不能再向上跳（两个点再向上跳 ( $2^0=1$ ) 层就能相遇），那此时任意点的父亲就是它们的最近公共祖先。\n\n```cpp\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);//默认depx>depy\n\tfor(int i=20;i>=0;i--)//从最大幂次开始尽可能向上跳\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];//深度还大于y就接着往上跳\n\t\tif(x==y)return x;//在这一步就相遇说明y就是最近的公共祖先（此时y=x）\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])//如果向上跳到的不是同一个点\n\t\t{\n\t\t\tx=fa[x][i];//一起向上跳2^i层\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];//最近公共祖先就是x，y任意点的父亲\n}\n```\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint to,nxt;\n}e[500010<<1];\nint fa[500010][22],dep[500010],cnt,head[500010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int now,int father)\n{\n\t//cout<<now<<\"k\"<<endl;\n\tdep[now]=dep[father]+1;\n\tfa[now][0]=father;\n\tfor(int i=1;(1<<i)<=dep[now];i++)\n\t{\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t\t//cout<<fa[now][i]<<\" \"<<now<<\" \"<<i<<endl;\n\t}\n\tfor(int i=head[now];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to!=father)\n\t\t\tdfs(e[i].to,now);\n\t}\n}\nint LCA(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t\tif(x==y)return x;\n\t}\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t}\n\treturn fa[x][0];\n}\nint main()\n{\n\t//memset(head,-1,sizeof(head));\n\tint n,m,s;\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tadd(a,b);\n\t\tadd(b,a); \n\t}\n\tdfs(s,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<LCA(a,b)<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n","tags":["树形结构","最近公共祖先","倍增"],"categories":["笔记"]},{"title":"P5536 【XR-3】核心城市","url":"/2022/06/28/4c28eade2351/","content":"# 【XR-3】核心城市\n\n## 题目描述\n\nX 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。\n\nX 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：\n\n1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。\n2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。\n\n## 输入格式\n\n第一行 $2$ 个正整数 $n,k$。\n\n接下来 $n - 1$ 行，每行 $2$ 个正整数 $u,v$，表示第 $u$ 座城市与第 $v$ 座城市之间有一条长度为 $1$ 的道路。\n\n**数据范围：**\n\n- $1 \\le k < n \\le 10 ^ 5$。\n- $1 \\le u,v \\le n, u \\ne v$，保证城市与道路形成一棵树。\n\n## 输出格式\n\n一行一个整数，表示答案。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n6 3\n1 2\n2 3\n2 4\n1 5\n5 6\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 提示\n\n【样例说明】\n\n钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。\n\n## 思路\n\n这道题的题目就有一点像在玩文字游戏的意思....\n\n简单来说：核心城市是一个团，其中每两个点都有链接。用yy能力把核心城市缩成一个点，要求的是所有点到核心城市点的最长距离的最小值。\n\n我们要做的是确定几个核心城市的位置，使得其他点到核心城市最长距离最小。\n\n先从简单的想起：假如就确定一个核心城市的位置，这个核心城市应该在哪？\n\n答案是整颗树直径的中点（可以理解为到每个最深结点的平均距离差值最小）。这时候到树上任意一点最大值最小。那么如果要令最大值最大，这个点应该在哪呢？\n\n答案是树的直径的端点。\n\n### 树的直径\n\n树的直径可以理解为树上最长的一条链。因此，接上文，如果在直径的端点，那么核心城市的距离就是树的直径（最长链），那最长距离必定最大。\n\n#### 如何求树的直径\n\n有两种方法：两次dfs（bfs）或者dp。dp方法不易求出树上的点，与我们要求出树的中心目的不符，在此仅介绍两次dfs做法。\n\n第一次dfs：任意选取一个点，开始dfs，搜索到最深处（树的直径的一个端点）\n\n第二次dfs：从树的端点开始dfs，dfs到最深处（树的另一个端点）\n\n这样求出来的就是最长链。在网上能搜到详细证明，在这里就不赘述，知道就行了。\n\n由于树的直径的中点必定在直径上（废话），因此可以在dfs的时候标记处整条直径，然后在直径上找出中点。\n\n两次dfs：\n```cpp\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)//mxdp是设置的目前最大深度，因为要找到最深的端点\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)//直径，和mxdp其实可以用同一个变量。\n\t{\n\t\tzj=dep;\n\t\ttag=x;//标记出另一个端点的编号\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;//标记出每个点的父亲。方便之后沿着链来寻找中点\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\n```\n为什么标记了父亲就能寻找到中点？因为我们通过第二次dfs可以找到另一个端点的编号，而在标记处该编号的父亲便可以通过寻找父亲一直寻找到直径的另一头。\n\n哪个是中点？直径长度一半就是中点。如果带有小数点 $0.5$ ，那说明有两个中点，无论哪个都可以。\n```cpp\nint mid=tag;//tag就是找出的另一个端点\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];//找直径/2次自己的父亲就是中点\n```\n解决了中点的问题，我们想起来：核心城市并不是一个点，它是很多个点构成的点集。那么对于除了直径中点以外的点怎么处理呢？\n\n贪心！\n\n每个点到这个点可以到达的最深点都有一个距离。而这个距离就是可能的最长链的长度。该距离 $d = maxdeep[x]-deep[x]$ ，即是该点可到达最深深度-自己的深度。如果将其从大到小排序，如果有k个核心城市，那么前k个就是第k长的最长链，是要去掉的。而 $d[k+1]+1$ 是我们所要求的最长链的最小值。\n\n例：假设 $k=3$\n\n从核心城市到它能到达的最深点（应该是直径一端）的距离为 $d[1]$ 。\n\n第二个城市 $d[2]$ 。\n\n第三个城市 $d[3]$。\n\n那么第四个城市（除了核心城市以外的第一座城市，即除了核心城市以外自身到最深点的最长链）$=d[4]$\n\n为什么还要 $+1$ ？\n\n因为我们求的 $d$ 是该点本身到该点能到达的最深深度的距离，他还要连接到核心城市上，这里是 $1$ 的距离，因此最后答案要 $+1 $。\n\n代码中用了四次dfs：\n\n第一次求出直径的一端\n\n第二次求出直径的另一端\n\n找出中点\n\n第三次以中点为树根标记各个节点深度\n\n第四次寻找每个深度的 $d$\n\n中间其实可以省略一次dfs，但是我觉得四次dfs也挺清晰的。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstruct edge{\n\tint to,nxt;\n}e[200010];\nint head[200010],cnt,dept[100010],mxdp,tag,mid;\nint dis[100010],fa[100010],zj,maxdeep[100010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nbool cmp(int a,int b){\n\treturn a>b;\n}\nvoid dfs1(int x,int father,int dep)\n{\n\tif(dep>mxdp)\n\t{\n\t\tmxdp=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs1(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int father,int dep)\n{\n\tif(dep>zj)\n\t{\n\t\tzj=dep;\n\t\ttag=x;\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tfa[to]=x;\n\t\t\tdfs2(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs3(int x,int father,int dep)\n{\n\tdept[x]=dep;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs3(to,x,dep+1);\n\t\t}\n\t}\n}\nvoid dfs4(int x,int father)\n{\n\tmaxdeep[x]=dept[x];\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=father)\n\t\t{\n\t\t\tdfs4(to,x);\n\t\t\tmaxdeep[x]=max(maxdeep[x],maxdeep[to]);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tadd(u,v),add(v,u);\n\t}\n\tdfs1(1,0,0);\n\tdfs2(tag,0,0);\n\tint mid=tag;\n\tfor(int i=1;i<=zj/2;i++)\n\t\tmid=fa[mid];\n\tdfs3(mid,0,0);\n\tdfs4(mid,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmaxdeep[i]-=dept[i];\n\t}\n\tsort(maxdeep+1,maxdeep+n+1,cmp);\n\tcout<<maxdeep[k+1]+1;\n\treturn 0;\n}\n```","tags":["树形结构","树的直径","贪心"],"categories":["题解"]},{"title":"P5018 [NOIP2018 普及组] 对称二叉树","url":"/2022/06/28/4d1511918017/","content":"\n# [NOIP2018 普及组] 对称二叉树\n\n## 题目描述\n\n一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： \n\n1.  二叉树； \n2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   \n\n下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  \n\n![](https://cdn.luogu.com.cn/upload/pic/43192.png)   \n\n现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。   \n\n注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。\n\n## 输入格式\n\n第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \\sim n$，其中节点 $1$ 是树根。 \n\n第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。 \n\n接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。\n\n## 输出格式\n\n输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2 \n1 3 \n2 -1 \n-1 -1\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n10 \n2 2 5 5 5 5 4 4 2 3 \n9 10 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 2 \n3 4 \n5 6 \n-1 -1 \n7 8\n```\n\n### 样例输出 #2\n\n```\n3\n```\n\n## 提示\n\n【输入输出样例 1 说明】  \n![](https://cdn.luogu.com.cn/upload/pic/43188.png)     \n最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   \n\n【输入输出样例 2 说明】   \n![](https://cdn.luogu.com.cn/upload/pic/43189.png)     \n最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 \n\n【数据规模与约定】    \n共 $25$ 个测试点。    \n$v_i ≤ 1000$。   \n测试点 $1 \\sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。   \n测试点 $4 \\sim 8, n ≤ 10$。  \n测试点 $9 \\sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。   \n测试点 $13 \\sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。  \n测试点 $17 \\sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。  \n测试点 $21 \\sim 25, n ≤ 10^6$。 \n \n本题约定： \n\n层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 \n \n 树的深度：树中节点的最大层次称为树的深度。 \n \n 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43190.png)  \n完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43191.png)\n\n\n ## 思路\n\n 树形结构的暴力，有助于提升对树的认知\n\n 目标：\n\n 1.判断二叉树结构是否对称\n\n 2.判断二叉树权值是否对称\n\n 3.判断二叉树的大小\n\n 把每个节点视作树的根，将其视作一棵二叉树，判断其结构、权值是否对称，计算其大小。通过递归可以得出。\n\n 判断二叉树对称：\n\n ```cpp\n bool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n ```\n ### 判断对称的条件：\n\n 1.左右都没有子树（都是-1），那么二叉树对称（只有自己节点，当然对称）\n\n 2.左右子树对称（结构对称且权值对称 $val[x]==val[y]$ ）。判断左右子树是否对称，可以采用1（该子树没有左右子树），或者2（该子树的左右子树对称），可以直接递归解决，即: $check(ls[x],rs[y])==1 且 check(ls[y],rs[x])==1 $ 。\n 令 $x$ 为该树左节点，$y$ 为该书右结点，则 $ls[x],rs[y]$ 代表其左节点的左子树和右节点的右子树，根据图片可以发现他们是满足对称的条件。另一个等式也是同样的道理\n\n 判断不对称：\n\n 1.只有一个子树存在\n\n 2.权值不等\n\n 3.左右子树不等\n\n ---------------------\n ### 判断树的子节点数\n\n 如果有左子树，加上左子树的节点数。对右子树同理。最后加上根节点（自己）\n\n```cpp\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\n```\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nint rs[1000100],ls[1000100],val[1000100],cnts[1000100];\nbool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>ls[i]>>rs[i];\n\tcnt(1);//默认1是根节点，从1号点开始找\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(check(ls[i],rs[i]))//经检查该树对称\n\t\t{\n\t\t\tans=max(ans,cnts[i]);//答案=目前最大值或者该树的节点数\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","递归"],"categories":["题解"]},{"title":"P1364 树的重心","url":"/2022/06/28/1b3206c4f64a/","content":"\n# 医院设置\n\n## 题目描述\n\n设有一棵二叉树，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/166.png)\n\n其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在1 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。\n\n## 输入格式\n\n第一行一个整数 $n$，表示树的结点数。\n\n接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。\n\n## 输出格式\n\n一个整数，表示最小距离和。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\t\t\t\t\t\t\n13 2 3\n4 0 0\n12 4 5\n20 0 0\n40 0 0\n```\n\n### 样例输出 #1\n\n```\n81\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。\n\n## 思路\n\n思路1：数据范围  $1 \\leq n \\leq 100$ ，可以考虑Floyd求最短路，求出任意两个点间最短距离，然后从1到N穷举医院的位置，找出最小值。\n\n思路2：加入数据更大呢？如果 $1 \\leq n \\leq 10000$ ，Floyd+穷举的方法肯定行不通。引出概念：树的重心。\n\n什么是树的重心？\n### 1.树的重心的定义：\n\n树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。\n\n### 2.树的重心的性质：\n\n1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。\n\n2、插入或删除一个点，树的重心的位置最多移动一个单位。\n\n3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。\n\n本题中只需要用到第一条性质，求出所有点（权）到树的重心的距离的最小值。\n\n### 3.如何求树的重心：\n\n动态规划求树的重心：定义 $f[i]$ 为以 $i$ 为根（医院）的总距离，$size[i]$ 为以 $i$为根的子树的总大小。\n\n那么有：$f[j] = f[i]+size[1]-2*size[j]$\n\n为什么？\n\n当根从 $i$ 变为 $j$ 时，根的子树到根的距离原先到 $i$ ，现在到 $j$ ，所有子树到根的距离都减小了1，而当前子树大小为 $size[j]$ ，因此减少的总距离为 $size[j]$ 。但是，除了子树之外的部分原先只要到 $i$ ，现在要到 $j$ 了，距离增加了1，因此增加的总距离为 $size[1]-size[j]$ 。于是可以得到：$f[j] = f[i]+size[1]-2*size[j]$ 。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[1010];\nint head[1010],n,pop[1010],cnt;\nint size[1010],ans=114514,f[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int x,int father,int dep)\n{\n\tsize[x]=pop[x];//因为本题中每个点有点权（人口），因此点权要计入树的大小。\n\tfor(int i=head[x];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tdfs(e[i].to,x,dep+1);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t}\n\t}\n\tf[1]+=(pop[x]*dep);//f[1]代表到f[1]的总距离，之后从f[1]开始向后进行dp\n}\nvoid dp(int u,int father)\n{\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tf[e[i].to]=f[u]+size[1]-2*size[e[i].to];\n\t\t\tdp(e[i].to,u);\n\t\t}\n\t\tans=min(f[u],ans);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pop[i];\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tif(u)add(i,u);\n\t\tif(v)add(i,v);\n\t}\n\tdfs(1,0,0);\n\tdp(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n```\n","tags":["树形结构","树的重心","最短路"],"categories":["题解"]},{"title":"P1352 没有上司的舞会","url":"/2022/06/28/b1aaafc3fcd9/","content":"# 没有上司的舞会\n## 题目描述\n\n某大学有 $ n $ 个职员，编号为 $1\\ldots n$。 \n\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n\n## 输入格式\n\n输入的第一行是一个整数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n\n第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n\n\n## 输出格式\n\n输出一行一个整数代表最大的快乐指数。\n\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n1\n1\n1\n1\n1\n1\n1\n1 3\n2 3\n6 4\n7 4\n4 5\n3 5\n```\n\n### 样例输出 #1\n\n```\n5\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq l, k \\leq n$，且给出的关系一定是一棵树。\n\n## 思路\n\n对于每一个人，有两种状态：来参加聚会或者不来参加聚会。能否使用 $f[i]$ 来表示这个人的位置能获得的最大幸福指数？不行。因为他是否去参加聚会对他之后的人是会产生影响的，即这个问题里是有后效性的。无后效性是dp里的一个重要问题，如果 $f[i]$ 就能获得该位置的最大幸福度，根据动态规划的无后效性定义：在 $f[i]$ 之后的 $f[i+1] \\ldots f[i+n]$ 与 $f[i]$ 是没有关系的，但是这道题中是否选择 $i$ 会对之后的状态产生影响，与无后效性矛盾，因此不能用 $f[i]$ 表示状态来进行动态规划。\n\n那么怎么用动态规划来解决这道问题呢？\n\n由于后效性实际上是对之后状态的不清楚。即：如果使用 $f[i]$ 表示状态，我们无法确定的表示出状态（取还是不取都会影响）。因此尝试加一维：即用 $f[i][0]$ 和 $f[i][1]$ 来表示两种状态：在 $i$ 时取这个人和不取这个人，然后分别根据两种状态来进行dp，似乎就可以做下去了。\n\n当不取第 $i$ 个人时候，$f[i][0]$ 在最初等于 $ 0 $ （因为不取他自己也就不加上他自身的快乐值 $r_i$），然后在 $f[i][0]=0$ 的基础上进行累加，找出它的最大值，即 $f[i][0] = max(f[son][1],f[son][0])$ 。即这个状态等于 $0 + 它下属能取到的最大快乐值 $ 。同理，当取第 $i$ 个人的时候，$f[i][1]=r_i$ 。（取了自身，加上自己的快乐值 $r_i$ ），状态转移方程为 $f[i][1] = r_i + max(f[son][0],f[son][1])$ 。\n\n因此，对于每个人的两种状态都进行一次状态转移，因为是从根部往下进行转移，因此动态规划的起点在这棵树的根部。\n\n先找出根部：由于每两个人之间都有记录上司的关系，因此在输入的时候为下属定义一个 $bool$ 型数组，记录它是否有上司，最后记录到没有上司的那个点就是树的根部（大领导）。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> son[10010]; \nint f[10010][2],r[10010],v[10010];\nvoid dp(int x)\n{\n\tf[x][0]=0;\n\tf[x][1]=r[x];\n\tfor(int i=0;i<son[x].size();i++)\n\t{\n\t\tint nxt=son[x][i];\n\t\tdp(nxt);\n\t\tf[x][0]+=max(f[nxt][0],f[nxt][1]);\n\t\tf[x][1]+=f[nxt][0];\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>r[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint l,k;\n\t\tcin>>l>>k;\n\t\tson[k].push_back(l);\n\t\tv[l]=1; //记录是否有上司\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!v[i])rt=i;\n\tdp(rt);\n\tcout<<max(f[rt][0],f[rt][1]);\n\treturn 0;\n}\n```","tags":["树形结构","树形dp"],"categories":["题解"]},{"title":"Hello World","url":"/2022/06/27/1fc55095b3bb/","content":"第一篇md博客试试水\n\n不会网站又404了吧\n\n好像没有404 找到之前一直404的原因了 大成功\n\n今天再调一调主题什么的乱七八糟的\n\n\n从下午两点开始整 整到下午六点 当时以为忽略每次推送CNAME消失而导致网页404直接把整个项目删除了又重新建了一个 解决了不知道多少奇奇怪怪的问题 终于感觉差不多搞好了\n\n目前用git推到github上的时候貌似还会经常出现网络问题(errno 10053和无法连接到github） 希望也能尽快解决吧\n\n----------\n\n2022/06/28 00：01\n\n之前本地预览hexo s可以正常浏览网页，但是部署之后一点除了主页之外的任何网页就寄，终于修好了，呜呜呜\n\n有点困，再修一会睡觉。7.4就要小学期学汇编语言了，怎么到今天都没人陪我玩游戏。\n\n\n----------\n\n2022/06/28 00:33\n\n把分类、标签、关于页面也弄出来了，大成功(bushi\n\n开森\n\n基础的网站算是搭好了\n\n------------\n\n2022/06/28 11:39\n\n解决了markdown不显示数学公式的问题\n\n------------------------\n\n2022/06/28 16:39\n\n更换了Mist主题，搭配canvas_nest感觉超级好看\n\n添加了搜索功能\n\n把代码块的样式美化成了Mac的样式\n\n添加了头像\n\n（这5个小时的工作内容）\n\n感觉美化工作也工作的差不多了！\n\n","tags":["碎碎念"],"categories":["随笔"]}]