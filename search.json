[{"title":"P5018 [NOIP2018 普及组] 对称二叉树","url":"/2022/06/28/4d1511918017/","content":"\n# [NOIP2018 普及组] 对称二叉树\n\n## 题目描述\n\n一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： \n\n1.  二叉树； \n2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   \n\n下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  \n\n![](https://cdn.luogu.com.cn/upload/pic/43192.png)   \n\n现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。   \n\n注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。\n\n## 输入格式\n\n第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \\sim n$，其中节点 $1$ 是树根。 \n\n第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。 \n\n接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。\n\n## 输出格式\n\n输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2 \n1 3 \n2 -1 \n-1 -1\n```\n\n### 样例输出 #1\n\n```\n1\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n10 \n2 2 5 5 5 5 4 4 2 3 \n9 10 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 -1 \n-1 2 \n3 4 \n5 6 \n-1 -1 \n7 8\n```\n\n### 样例输出 #2\n\n```\n3\n```\n\n## 提示\n\n【输入输出样例 1 说明】  \n![](https://cdn.luogu.com.cn/upload/pic/43188.png)     \n最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   \n\n【输入输出样例 2 说明】   \n![](https://cdn.luogu.com.cn/upload/pic/43189.png)     \n最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 \n\n【数据规模与约定】    \n共 $25$ 个测试点。    \n$v_i ≤ 1000$。   \n测试点 $1 \\sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。   \n测试点 $4 \\sim 8, n ≤ 10$。  \n测试点 $9 \\sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。   \n测试点 $13 \\sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。  \n测试点 $17 \\sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。  \n测试点 $21 \\sim 25, n ≤ 10^6$。 \n \n本题约定： \n\n层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 \n \n 树的深度：树中节点的最大层次称为树的深度。 \n \n 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43190.png)  \n完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  \n ![](https://cdn.luogu.com.cn/upload/pic/43191.png)\n\n\n ## 思路\n\n 树形结构的暴力，有助于提升对树的认知\n\n 目标：\n\n 1.判断二叉树结构是否对称\n\n 2.判断二叉树权值是否对称\n\n 3.判断二叉树的大小\n\n 把每个节点视作树的根，将其视作一棵二叉树，判断其结构、权值是否对称，计算其大小。通过递归可以得出。\n\n 判断二叉树对称：\n\n ```cpp\n bool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n ```\n ### 判断对称的条件：\n\n 1.左右都没有子树（都是-1），那么二叉树对称（只有自己节点，当然对称）\n\n 2.左右子树对称（结构对称且权值对称 $val[x]==val[y]$ ）。判断左右子树是否对称，可以采用1（该子树没有左右子树），或者2（该子树的左右子树对称），可以直接递归解决，即: $check(ls[x],rs[y])==1 且 check(ls[y],rs[x])==1 $ 。\n 令 $x$ 为该树左节点，$y$ 为该书右结点，则 $ls[x],rs[y]$ 代表其左节点的左子树和右节点的右子树，根据图片可以发现他们是满足对称的条件。另一个等式也是同样的道理\n\n 判断不对称：\n\n 1.只有一个子树存在\n\n 2.权值不等\n\n 3.左右子树不等\n\n ---------------------\n ### 判断树的子节点数\n\n 如果有左子树，加上左子树的节点数。对右子树同理。最后加上根节点（自己）\n\n```cpp\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\n```\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nint rs[1000100],ls[1000100],val[1000100],cnts[1000100];\nbool check(int x,int y)\n{\n\tif(x==-1 && y==-1)return 1;\n\telse{\n\t\tif(x!=-1 && y!=-1 && val[x]==val[y] && check(ls[x],rs[y]) && check(ls[y],rs[x]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint cnt(int x)\n{\n\tif(rs[x]!=-1)cnts[x]+=cnt(rs[x]);\n\tif(ls[x]!=-1)cnts[x]+=cnt(ls[x]);\n\treturn ++cnts[x];\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>val[i];\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>ls[i]>>rs[i];\n\tcnt(1);//默认1是根节点，从1号点开始找\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(check(ls[i],rs[i]))//经检查该树对称\n\t\t{\n\t\t\tans=max(ans,cnts[i]);//答案=目前最大值或者该树的节点数\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```","tags":["树形结构","递归"],"categories":["题解"]},{"title":"P1364 树的重心","url":"/2022/06/28/1b3206c4f64a/","content":"\n# 医院设置\n\n## 题目描述\n\n设有一棵二叉树，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/166.png)\n\n其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在1 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。\n\n## 输入格式\n\n第一行一个整数 $n$，表示树的结点数。\n\n接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。\n\n## 输出格式\n\n一个整数，表示最小距离和。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\t\t\t\t\t\t\n13 2 3\n4 0 0\n12 4 5\n20 0 0\n40 0 0\n```\n\n### 样例输出 #1\n\n```\n81\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。\n\n## 思路\n\n思路1：数据范围  $1 \\leq n \\leq 100$ ，可以考虑Floyd求最短路，求出任意两个点间最短距离，然后从1到N穷举医院的位置，找出最小值。\n\n思路2：加入数据更大呢？如果 $1 \\leq n \\leq 10000$ ，Floyd+穷举的方法肯定行不通。引出概念：树的重心。\n\n什么是树的重心？\n### 1.树的重心的定义：\n\n树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。\n\n### 2.树的重心的性质：\n\n1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。\n\n2、插入或删除一个点，树的重心的位置最多移动一个单位。\n\n3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。\n\n本题中只需要用到第一条性质，求出所有点（权）到树的重心的距离的最小值。\n\n### 3.如何求树的重心：\n\n动态规划求树的重心：定义 $f[i]$ 为以 $i$ 为根（医院）的总距离，$size[i]$ 为以 $i$为根的子树的总大小。\n\n那么有：$f[j] = f[i]+size[1]-2*size[j]$\n\n为什么？\n\n当根从 $i$ 变为 $j$ 时，根的子树到根的距离原先到 $i$ ，现在到 $j$ ，所有子树到根的距离都减小了1，而当前子树大小为 $size[j]$ ，因此减少的总距离为 $size[j]$ 。但是，除了子树之外的部分原先只要到 $i$ ，现在要到 $j$ 了，距离增加了1，因此增加的总距离为 $size[1]-size[j]$ 。于是可以得到：$f[j] = f[i]+size[1]-2*size[j]$ 。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[1010];\nint head[1010],n,pop[1010],cnt;\nint size[1010],ans=114514,f[1010];\nvoid add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int x,int father,int dep)\n{\n\tsize[x]=pop[x];//因为本题中每个点有点权（人口），因此点权要计入树的大小。\n\tfor(int i=head[x];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tdfs(e[i].to,x,dep+1);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t}\n\t}\n\tf[1]+=(pop[x]*dep);//f[1]代表到f[1]的总距离，之后从f[1]开始向后进行dp\n}\nvoid dp(int u,int father)\n{\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tif(e[i].to!=father)\n\t\t{\n\t\t\tf[e[i].to]=f[u]+size[1]-2*size[e[i].to];\n\t\t\tdp(e[i].to,u);\n\t\t}\n\t\tans=min(f[u],ans);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pop[i];\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tif(u)add(i,u);\n\t\tif(v)add(i,v);\n\t}\n\tdfs(1,0,0);\n\tdp(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n```\n","tags":["树形结构","树的重心","最短路"],"categories":["题解"]},{"title":"P1352 没有上司的舞会","url":"/2022/06/28/b1aaafc3fcd9/","content":"# 没有上司的舞会\n## 题目描述\n\n某大学有 $ n $ 个职员，编号为 $1\\ldots n$。 \n\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n\n## 输入格式\n\n输入的第一行是一个整数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n\n第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n\n\n## 输出格式\n\n输出一行一个整数代表最大的快乐指数。\n\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n7\n1\n1\n1\n1\n1\n1\n1\n1 3\n2 3\n6 4\n7 4\n4 5\n3 5\n```\n\n### 样例输出 #1\n\n```\n5\n```\n\n## 提示\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq l, k \\leq n$，且给出的关系一定是一棵树。\n\n## 思路\n\n对于每一个人，有两种状态：来参加聚会或者不来参加聚会。能否使用 $f[i]$ 来表示这个人的位置能获得的最大幸福指数？不行。因为他是否去参加聚会对他之后的人是会产生影响的，即这个问题里是有后效性的。无后效性是dp里的一个重要问题，如果 $f[i]$ 就能获得该位置的最大幸福度，根据动态规划的无后效性定义：在 $f[i]$ 之后的 $f[i+1] \\ldots f[i+n]$ 与 $f[i]$ 是没有关系的，但是这道题中是否选择 $i$ 会对之后的状态产生影响，与无后效性矛盾，因此不能用 $f[i]$ 表示状态来进行动态规划。\n\n那么怎么用动态规划来解决这道问题呢？\n\n由于后效性实际上是对之后状态的不清楚。即：如果使用 $f[i]$ 表示状态，我们无法确定的表示出状态（取还是不取都会影响）。因此尝试加一维：即用 $f[i][0]$ 和 $f[i][1]$ 来表示两种状态：在 $i$ 时取这个人和不取这个人，然后分别根据两种状态来进行dp，似乎就可以做下去了。\n\n当不取第 $i$ 个人时候，$f[i][0]$ 在最初等于 $ 0 $ （因为不取他自己也就不加上他自身的快乐值 $r_i$），然后在 $f[i][0]=0$ 的基础上进行累加，找出它的最大值，即 $f[i][0] = max(f[son][1],f[son][0])$ 。即这个状态等于 $0 + 它下属能取到的最大快乐值 $ 。同理，当取第 $i$ 个人的时候，$f[i][1]=r_i$ 。（取了自身，加上自己的快乐值 $r_i$ ），状态转移方程为 $f[i][1] = r_i + max(f[son][0],f[son][1])$ 。\n\n因此，对于每个人的两种状态都进行一次状态转移，因为是从根部往下进行转移，因此动态规划的起点在这棵树的根部。\n\n先找出根部：由于每两个人之间都有记录上司的关系，因此在输入的时候为下属定义一个 $bool$ 型数组，记录它是否有上司，最后记录到没有上司的那个点就是树的根部（大领导）。\n\n## 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> son[10010]; \nint f[10010][2],r[10010],v[10010];\nvoid dp(int x)\n{\n\tf[x][0]=0;\n\tf[x][1]=r[x];\n\tfor(int i=0;i<son[x].size();i++)\n\t{\n\t\tint nxt=son[x][i];\n\t\tdp(nxt);\n\t\tf[x][0]+=max(f[nxt][0],f[nxt][1]);\n\t\tf[x][1]+=f[nxt][0];\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>r[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint l,k;\n\t\tcin>>l>>k;\n\t\tson[k].push_back(l);\n\t\tv[l]=1; //记录是否有上司\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!v[i])rt=i;\n\tdp(rt);\n\tcout<<max(f[rt][0],f[rt][1]);\n\treturn 0;\n}\n```","tags":["树形dp","树形结构"],"categories":["题解"]},{"title":"Hello World","url":"/2022/06/27/1fc55095b3bb/","content":"第一篇md博客试试水\n\n不会网站又404了吧\n\n好像没有404 找到之前一直404的原因了 大成功\n\n今天再调一调主题什么的乱七八糟的\n\n\n从下午两点开始整 整到下午六点 当时以为忽略每次推送CNAME消失而导致网页404直接把整个项目删除了又重新建了一个 解决了不知道多少奇奇怪怪的问题 终于感觉差不多搞好了\n\n目前用git推到github上的时候貌似还会经常出现网络问题(errno 10053和无法连接到github） 希望也能尽快解决吧\n\n----------\n\n2022/06/28 00：01\n\n之前本地预览hexo s可以正常浏览网页，但是部署之后一点除了主页之外的任何网页就寄，终于修好了，呜呜呜\n\n有点困，再修一会睡觉。7.4就要小学期学汇编语言了，怎么到今天都没人陪我玩游戏。\n\n\n----------\n\n2022/06/28 00:33\n\n把分类、标签、关于页面也弄出来了，大成功(bushi\n\n开森\n\n基础的网站算是搭好了\n\n------------\n\n2022/06/28 11:39\n\n解决了markdown不显示数学公式的问题\n\n------------------------\n\n2022/06/28 16:39\n\n更换了Mist主题，搭配canvas_nest感觉超级好看\n\n添加了搜索功能\n\n把代码块的样式美化成了Mac的样式\n\n添加了头像\n\n（这5个小时的工作内容）\n\n感觉美化工作也工作的差不多了！\n\n","tags":["碎碎念"],"categories":["随笔"]}]